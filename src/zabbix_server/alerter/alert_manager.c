/*
** Zabbix
** Copyright (C) 2001-2020 Zabbix SIA
**
** This program is free software; you can redistribute it and/or modify
** it under the terms of the GNU General Public License as published by
** the Free Software Foundation; either version 2 of the License, or
** (at your option) any later version.
**
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
** GNU General Public License for more details.
**
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
**/

#include "common.h"

#include "daemon.h"
#include "zbxself.h"
#include "log.h"
#include "zbxipcservice.h"
#include "zbxalgo.h"
#include "zbxserver.h"
#include "alerter_protocol.h"
#include "alert_manager.h"

#define ZBX_AM_LOCATION_NOWHERE		0
#define ZBX_AM_LOCATION_QUEUE		1

#define ZBX_UPDATE_STR(dst, src)	if (NULL == dst || 0 != strcmp(dst, src)) dst = zbx_strdup(dst, src);

#define ZBX_WATCHDOG_ALERT_FREQUENCY	(15 * SEC_PER_MIN)

#define ZBX_AM_DB_POLL_DELAY	1

extern unsigned char	process_type, program_type;
extern int		server_num, process_num;

extern int	CONFIG_ALERTER_FORKS;
extern int	CONFIG_CONFSYNCER_FREQUENCY;
extern char	*CONFIG_ALERT_SCRIPTS_PATH;

/*
 * The alert queue is implemented as a nested queue.
 *
 * At the bottom layer is media type queue, enforcing the media type maxsessions setting.
 * At the next layer is alert pool queue. Alert pool is an artificial construct to group
 * alerts generated by the same source (event source, object and objectid) so that they
 * are executed sequentially.
 * At the top layer is alert queue.
 *
 * mediatypes
 *     alertpools
 *         alerts
 *
 * Media type queue is sorted by the timestamp of the miminum item of its alertpool queue.
 * Alert pool queue is sorted by the timestamp of the minimum item of its alerts queue.
 * Alerts queue is sorted by the alert scheduled send timestamp.
 *
 * When taking the next alert to send the following actions are done:
 *    1) take the next media type object from media type queue
 *    2) take the next alert pool object from media type alertpool queue
 *    3) take the next alert from alert pool alerts queue
 *    4) if media type maxsessions limit has not reached, put the media type object back in queue
 *
 * When processing alert response the following actions are done:
 *    1) find alerts media type and alert pool objects
 *    2) cache alert status update to be flushed into database later
 *    3) if alert failed and can be retried put it back into its alert pool queue,
 *       otherwise free the alert object
 *    4) release alert pool object, put it back into media type alertpools queue if the alert pool
 *       was not removed
 *    5) release media type object, put it back into media types queue if the media type object
 *       was not removed
 */

typedef struct
{
	zbx_uint64_t	mediaid;
	zbx_uint64_t	mediatypeid;
	char		*sendto;
}
zbx_am_media_t;

/* alert data */
typedef struct
{
	zbx_uint64_t	alertid;
	zbx_uint64_t	mediatypeid;
	zbx_uint64_t	alertpoolid;
	int		nextsend;

	/* alert data */
	char		*sendto;
	char		*subject;
	char		*message;
	int		status;
	int		retries;
}
zbx_am_alert_t;

/* Alert pool data.                                                          */
/* Alerts are assigned to pools based on event source, object and objectid.  */
/* While alert pools can be processed in parallel, alerts inside alert pool  */
/* are processed sequentially.                                               */
typedef struct
{
	zbx_uint64_t		id;
	zbx_uint64_t		mediatypeid;

	/* alert queue */
	zbx_binary_heap_t	queue;

	int			location;
	int			alerts_num;

	/* the number of alert objects for this alert pool */
	int			refcount;
}
zbx_am_alertpool_t;

/* media type data */
typedef struct
{
	zbx_uint64_t		mediatypeid;

	int			location;
	int			alerts_num;

	/* the number of alert objects for this media type */
	int			refcount;

	/* alert pool queue */
	zbx_binary_heap_t	queue;

	/* media type data */
	int			type;
	char			*description;
	char			*smtp_server;
	char			*smtp_helo;
	char			*smtp_email;
	char			*exec_path;
	char			*gsm_modem;
	char			*username;
	char			*passwd;
	char			*exec_params;
	unsigned short		smtp_port;
	unsigned char		smtp_security;
	unsigned char		smtp_verify_peer;
	unsigned char		smtp_verify_host;
	unsigned char		smtp_authentication;

	int			maxsessions;
	int			maxattempts;
	int			attempt_interval;
}
zbx_am_mediatype_t;

/* alert status update data */
typedef struct
{
	zbx_uint64_t	alertid;
	int		retries;
	int		status;
	char		*error;
}
zbx_am_alertstatus_t;

/* alerter data */
typedef struct
{
	/* the connected aleter client */
	zbx_ipc_client_t	*client;

	zbx_am_alert_t		*alert;
}
zbx_am_alerter_t;

/* alert manager data */
typedef struct
{
	/* alerter vector, created during manager initialization */
	zbx_vector_ptr_t	alerters;
	zbx_queue_ptr_t		free_alerters;

	/* alerters indexed by IPC service clients */
	zbx_hashset_t		alerters_client;

	/* the next alerter index to be assigned to new IPC service clients */
	int			next_alerter_index;

	zbx_hashset_t		mediatypes;
	zbx_hashset_t		alertpools;

	/* the alert status update cache */
	zbx_hashset_t		alertupdates;

	/* the watchdog alert recipients */
	zbx_hashset_t		watchdog;

	/* mediatype queue */
	zbx_binary_heap_t	queue;

	/* the database status */
	int			dbstatus;
}
zbx_am_t;

/* alerters client index hashset support */

/******************************************************************************
 * *
 *这块代码的主要目的是定义一个名为alerter_hash_func的静态函数，该函数接收一个const void *类型的指针d作为参数。通过对d指针进行解引用，将其转换为zbx_am_alerter_t类型的指针，并将其命名为alerter。接着，调用zbx_hash_t类型的默认指针哈希函数，将alerter->client的地址作为参数传入，得到一个哈希值。最后，将计算得到的哈希值返回。
 ******************************************************************************/
// 定义一个名为alerter_hash_func的静态函数，参数为const void *类型的指针d
static zbx_hash_t alerter_hash_func(const void *d)
{
	// 解引用指针d，将其转换为zbx_am_alerter_t类型的指针，并将其命名为alerter
	const zbx_am_alerter_t *alerter = *(const zbx_am_alerter_t **)d;
/******************************************************************************
 * *
 *整个代码块的主要目的是定义一个名为alerter_compare_func的静态函数，该函数用于比较两个zbx_am_alerter_t结构体对象的大小。在此过程中，首先解引用指针d1和d2，分别获取指向的zbx_am_alerter_t结构体对象。然后检查两个对象中的客户端（client）字段是否相等，如果不相等，返回1，表示比较大小的操作失败。如果客户端字段相等，返回0，表示比较大小的操作成功。
 ******************************************************************************/
// 定义一个名为alerter_compare_func的静态函数，该函数用于比较两个zbx_am_alerter_t结构体对象的大小
static int	alerter_compare_func(const void *d1, const void *d2)
{
	// 解引用指针d1和d2，分别获取指向的zbx_am_alerter_t结构体对象
	const zbx_am_alerter_t	*p1 = *(const zbx_am_alerter_t **)d1;
	const zbx_am_alerter_t	*p2 = *(const zbx_am_alerter_t **)d2;

	// 检查两个zbx_am_alerter_t对象中的客户端（client）字段是否相等，如果不相等，返回1，表示比较大小的操作失败
	ZBX_RETURN_IF_NOT_EQUAL(p1->client, p2->client);

	// 如果客户端字段相等，返回0，表示比较大小的操作成功
	return 0;
}

static int	alerter_compare_func(const void *d1, const void *d2)
{
	const zbx_am_alerter_t	*p1 = *(const zbx_am_alerter_t **)d1;
/******************************************************************************
 * *
 *这块代码的主要目的是定义一个名为 am_alertpool_hash_func 的静态函数，该函数用于计算一个 zbx_am_alertpool_t 结构体对象的哈希值。函数接收一个 void* 类型的参数 data，将其转换为 zbx_am_alertpool_t 类型，并使用两个哈希函数分别计算其 id 和 mediatypeid 成员的哈希值。最后将两个哈希值拼接在一起，并返回计算出的哈希值。
 ******************************************************************************/
// 定义一个名为 am_alertpool_hash_func 的函数，该函数接收一个 void* 类型的参数 data
static zbx_hash_t	am_alertpool_hash_func(const void *data)
{
	// 类型转换，将 data 指针转换为 const zbx_am_alertpool_t 类型，并将其命名为 pool
	const zbx_am_alertpool_t	*pool = (const zbx_am_alertpool_t *)data;

	// 定义一个名为 hash 的 zbx_hash_t 类型变量，用于存储计算出的哈希值
	zbx_hash_t			hash;

	// 使用 ZBX_DEFAULT_UINT64_HASH_FUNC 函数计算 pool->id 的哈希值，并将结果存储在 hash 变量中
	hash = ZBX_DEFAULT_UINT64_HASH_FUNC(&pool->id);

	// 使用 ZBX_DEFAULT_UINT64_HASH_ALGO 函数计算 pool->mediatypeid 的哈希值，并将结果与 hash 变量进行拼接
	hash = ZBX_DEFAULT_UINT64_HASH_ALGO(&pool->mediatypeid, sizeof(pool->mediatypeid), hash);

	// 返回计算出的哈希值
	return hash;
}

	const zbx_am_alertpool_t	*pool = (const zbx_am_alertpool_t *)data;

	zbx_hash_t			hash;

	hash = ZBX_DEFAULT_UINT64_HASH_FUNC(&pool->id);
	hash = ZBX_DEFAULT_UINT64_HASH_ALGO(&pool->mediatypeid, sizeof(pool->mediatypeid), hash);

	return hash;
}

/******************************************************************************
 * *
 *这块代码的主要目的是比较两个 alertpool 结构体实例的相似度。函数 am_alertpool_compare_func 接收两个 void 类型的指针作为参数，分别解引用为 zbx_am_alertpool_t 类型的指针 pool1 和 pool2。然后检查两个 alertpool 实例的 id 和 mediatypeid 字段是否相等，如果不相等，则返回错误码。如果这两个字段都相等，则认为两个 alertpool 实例相似度较高，返回 0。
 ******************************************************************************/
// 定义一个名为 am_alertpool_compare_func 的静态函数，该函数用于比较两个 alertpool 结构体实例的相似度
static int	am_alertpool_compare_func(const void *d1, const void *d2)
{
	// 将传入的指针 d1 和 d2 分别解引用为 zbx_am_alertpool_t 类型的指针 pool1 和 pool2
	const zbx_am_alertpool_t	*pool1 = (const zbx_am_alertpool_t *)d1;
	const zbx_am_alertpool_t	*pool2 = (const zbx_am_alertpool_t *)d2;

	// 检查两个 alertpool 实例的 id 字段是否相等，如果不相等，则返回错误码
	ZBX_RETURN_IF_NOT_EQUAL(pool1->id, pool2->id);

	// 检查两个 alertpool 实例的 mediatypeid 字段是否相等，如果不相等，则返回错误码
	ZBX_RETURN_IF_NOT_EQUAL(pool1->mediatypeid, pool2->mediatypeid);

	// 如果上述两个条件都不满足，则返回 0，表示两个 alertpool 实例相似度较高
	return 0;
}


/* queue support */

/******************************************************************************
 * *
 *整个代码块的主要目的是比较两个 zbx_am_alert_t 结构体指针（alert1 和 alert2）指向的对象是否相等。具体来说，该函数会检查 alert1 和 alert2 的 nextsend 和 alertid 成员是否相等。如果这两个成员不相等，函数会返回一个错误码；如果相等，则返回 0，表示比较成功。
 ******************************************************************************/
// 定义一个名为 am_alert_compare 的静态函数，参数为两个指向 zbx_am_alert_t 结构体的指针
static int am_alert_compare(const zbx_am_alert_t *alert1, const zbx_am_alert_t *alert2)
{
    // 判断 alert1->nextsend 和 alert2->nextsend 是否不相等，如果不相等，则返回错误码
    ZBX_RETURN_IF_NOT_EQUAL(alert1->nextsend, alert2->nextsend);

    // 判断 alert1->alertid 和 alert2->alertid 是否不相等，如果不相等，则返回错误码
    ZBX_RETURN_IF_NOT_EQUAL(alert1->alertid, alert2->alertid);

    // 如果上述条件都满足，则返回 0，表示比较成功
    return 0;
}
/******************************************************************************
 * *
 *整个代码块的主要目的是比较两个 alert 池（zbx_am_alertpool_t 结构体）中的最小元素（即队头元素）。这里使用 zbx_binary_heap_t 结构体来实现 alert 池，通过查找队列最小元素（zbx_binary_heap_find_min 函数）分别获取两个 alert 池的最小元素，然后调用 am_alert_compare 函数比较这两个最小元素的数据。最终返回比较结果。
 ******************************************************************************/
// 定义一个名为 am_alertpool_compare 的静态函数，参数为两个指向 zbx_am_alertpool_t 结构体的指针
static int	am_alertpool_compare(const zbx_am_alertpool_t *pool1, const zbx_am_alertpool_t *pool2)
{
	// 定义两个指向 zbx_binary_heap_t 结构体的指针，分别指向 pool1 和 pool2 的队列最小元素
	zbx_binary_heap_elem_t	*e1, *e2;

	// 查找 pool1 中的队列最小元素，将其存储在 e1 指针所指向的 zbx_binary_heap_elem_t 结构体中
	e1 = zbx_binary_heap_find_min((zbx_binary_heap_t *)&pool1->queue);
	// 查找 pool2 中的队列最小元素，将其存储在 e2 指针所指向的 zbx_binary_heap_elem_t 结构体中
	e2 = zbx_binary_heap_find_min((zbx_binary_heap_t *)&pool2->queue);

	// 调用 am_alert_compare 函数，比较 e1 和 e2 指向的 zbx_am_alert_t 结构体中的数据，返回比较结果
	return am_alert_compare((const zbx_am_alert_t *)e1->data, (const zbx_am_alert_t *)e2->data);
}

 *
 *注释中已经详细说明了每一行代码的作用，以及整个代码块的主要目的。
 ******************************************************************************/
// 定义一个静态函数，用于比较两个zbx_binary_heap_elem_t结构体元素
static int	am_alert_queue_compare(const void *d1, const void *d2)
{
	// 将传入的指针d1和d2转换为zbx_binary_heap_elem_t结构体类型的指针
	const zbx_binary_heap_elem_t	*e1 = (const zbx_binary_heap_elem_t *)d1;
	const zbx_binary_heap_elem_t	*e2 = (const zbx_binary_heap_elem_t *)d2;

	// 调用am_alert_compare函数，比较两个zbx_am_alert_t结构体元素
	// 这里假设am_alert_compare函数的返回值是负数时，表示第一个元素小于第二个元素
	// 返回0表示两个元素相等，返回正数表示第一个元素大于第二个元素
	return am_alert_compare((const zbx_am_alert_t *)e1->data, (const zbx_am_alert_t *)e2->data);
}


static int	am_alertpool_compare(const zbx_am_alertpool_t *pool1, const zbx_am_alertpool_t *pool2)
{
	zbx_binary_heap_elem_t	*e1, *e2;

	e1 = zbx_binary_heap_find_min((zbx_binary_heap_t *)&pool1->queue);
	e2 = zbx_binary_heap_find_min((zbx_binary_heap_t *)&pool2->queue);

	return am_alert_compare((const zbx_am_alert_t *)e1->data, (const zbx_am_alert_t *)e2->data);
}

/******************************************************************************
 * *
 *这段代码的主要目的是定义一个静态函数`am_alertpool_queue_compare`，用于比较两个zbx_binary_heap_elem_t结构体实例。通过将传入的指针d1和d2转换为zbx_binary_heap_elem_t结构体指针，然后调用am_alertpool_compare函数来比较两个zbx_am_alertpool_t结构体实例。返回值表示比较结果，负数表示第一个实例小于第二个实例，0表示相等，正数表示第一个实例大于第二个实例。
 ******************************************************************************/
// 定义一个静态函数，用于比较两个zbx_binary_heap_elem_t结构体实例
static int	am_alertpool_queue_compare(const void *d1, const void *d2)
{
	// 将传入的指针d1和d2转换为zbx_binary_heap_elem_t结构体指针
	const zbx_binary_heap_elem_t	*e1 = (const zbx_binary_heap_elem_t *)d1;
	const zbx_binary_heap_elem_t	*e2 = (const zbx_binary_heap_elem_t *)d2;

	// 调用am_alertpool_compare函数，比较两个zbx_am_alertpool_t结构体实例
	// 这里假设am_alertpool_compare函数的返回值是负数时，表示第一个实例小于第二个实例
	// 返回0表示两个实例相等，返回正数表示第一个实例大于第二个实例
	return am_alertpool_compare((const zbx_am_alertpool_t *)e1->data, (const zbx_am_alertpool_t *)e2->data);
}


/******************************************************************************
 * *
 *整个代码块的主要目的是比较两个媒体类型（media1和media2）的优先级。通过查找两个媒体类型的优先级队列中的最小元素，然后使用am_alertpool_compare函数比较这两个最小元素。最终返回比较结果。
 ******************************************************************************/
// 定义一个静态函数，用于比较两个媒体类型（media1和media2）的优先级
static int am_mediatype_compare(const zbx_am_mediatype_t *media1, const zbx_am_mediatype_t *media2)
{
	// 定义两个指向二叉堆元素的指针，分别指向media1和media2的优先级队列的最小元素
	zbx_binary_heap_elem_t *e1, *e2;

	// 查找media1的优先级队列中的最小元素
	e1 = zbx_binary_heap_find_min((zbx_binary_heap_t *)&media1->queue);
	// 查找media2的优先级队列中的最小元素
	e2 = zbx_binary_heap_find_min((zbx_binary_heap_t *)&media2->queue);

	// 比较两个最小元素（即两个媒体类型的优先级）
	return am_alertpool_compare((const zbx_am_alertpool_t *)e1->data, (const zbx_am_alertpool_t *)e2->data);
}


/******************************************************************************
 * *
 *代码块主要目的是：定义一个静态函数`am_mediatype_queue_compare`，用于比较两个`zbx_binary_heap_elem_t`结构体实例。通过转换指针`d1`和`d2`为`zbx_binary_heap_elem_t`类型的指针，然后调用`am_mediatype_compare`函数比较两个`zbx_am_mediatype_t`类型的实例。
 ******************************************************************************/
// 定义一个静态函数，用于比较两个zbx_binary_heap_elem_t结构体实例
static int	am_mediatype_queue_compare(const void *d1, const void *d2)
{
	// 将指针d1和d2转换为zbx_binary_heap_elem_t类型的指针
	const zbx_binary_heap_elem_t	*e1 = (const zbx_binary_heap_elem_t *)d1;
	const zbx_binary_heap_elem_t	*e2 = (const zbx_binary_heap_elem_t *)d2;

	// 调用am_mediatype_compare函数，比较两个zbx_am_mediatype_t类型的实例
	// 参数1：指向zbx_am_mediatype_t实例的指针
	// 参数2：指向zbx_am_mediatype_t实例的指针
	return am_mediatype_compare((const zbx_am_mediatype_t *)e1->data, (const zbx_am_mediatype_t *)e2->data);
}


/******************************************************************************
 *                                                                            *
 * Function: am_get_mediatype                                                 *
 *                                                                            *
 * Purpose: gets media type object                                            *
 *                                                                            *
 * Parameters: manager     - [IN] the alert manager                           *
/******************************************************************************
 * *
 *整个代码块的主要目的是更新媒体类型，包括媒体类型的类型、描述、SMTP服务器、SMTP问候语、SMTP发件人等信息，以及SMTP端口、安全级别、验证peer和host以及身份验证方式等。同时，还更新了媒体类型的最大会话数、最大尝试次数和尝试间隔等参数。
 ******************************************************************************/
// 定义一个静态函数，用于更新媒体类型
static void am_update_mediatype(zbx_am_t *manager, zbx_uint64_t mediatypeid, int type,
                               const char *description, const char *smtp_server, const char *smtp_helo,
                               const char *smtp_email, const char *exec_path, const char *gsm_modem,
                               const char *username, const char *passwd, unsigned short smtp_port,
                               unsigned char smtp_security, unsigned char smtp_verify_peer,
                               unsigned char smtp_verify_host, unsigned char smtp_authentication,
                               const char *exec_params, int maxsessions, int maxattempts,
                               int attempt_interval)
{
    // 定义一个媒体类型结构体指针
    zbx_am_mediatype_t *mediatype;

    // 检查是否存在媒体类型，如果不存在，则创建一个新的媒体类型
    if (NULL == (mediatype = am_get_mediatype(manager, mediatypeid)))
    {
        // 创建一个本地媒体类型结构体
        zbx_am_mediatype_t mediatype_local = {
            .mediatypeid = mediatypeid,
            .location = ZBX_AM_LOCATION_NOWHERE
        };

        // 将本地媒体类型插入到管理器的媒体类型集合中
        mediatype = (zbx_am_mediatype_t *)zbx_hashset_insert(&manager->mediatypes, &mediatype_local,
                                                             sizeof(mediatype_local));

        // 创建一个二叉堆，用于存储媒体类型的队列
        zbx_binary_heap_create(&mediatype->queue, am_alertpool_queue_compare,
                               ZBX_BINARY_HEAP_OPTION_DIRECT);
    }

    // 更新媒体类型的类型
    mediatype->type = type;

    // 更新媒体类型的描述、SMTP服务器、SMTP问候语、SMTP发件人等字符串信息
    ZBX_UPDATE_STR(mediatype->description, description);
    ZBX_UPDATE_STR(mediatype->smtp_server, smtp_server);
    ZBX_UPDATE_STR(mediatype->smtp_helo, smtp_helo);
    ZBX_UPDATE_STR(mediatype->smtp_email, smtp_email);
    ZBX_UPDATE_STR(mediatype->exec_path, exec_path);
    ZBX_UPDATE_STR(mediatype->exec_params, exec_params);
    ZBX_UPDATE_STR(mediatype->gsm_modem, gsm_modem);
    ZBX_UPDATE_STR(mediatype->username, username);
    ZBX_UPDATE_STR(mediatype->passwd, passwd);

    // 更新媒体类型的SMTP端口、安全级别、验证 peer 和 host 以及身份验证方式等信息
    mediatype->smtp_port = smtp_port;
    mediatype->smtp_security = smtp_security;
    mediatype->smtp_verify_peer = smtp_verify_peer;
    mediatype->smtp_verify_host = smtp_verify_host;
    mediatype->smtp_authentication = smtp_authentication;

    // 更新媒体类型的最大会话数、最大尝试次数和尝试间隔等信息
    mediatype->maxsessions = maxsessions;
    mediatype->maxattempts = maxattempts;
    mediatype->attempt_interval = attempt_interval;
}

		mediatype = (zbx_am_mediatype_t *)zbx_hashset_insert(&manager->mediatypes, &mediatype_local,
				sizeof(mediatype_local));

		zbx_binary_heap_create(&mediatype->queue, am_alertpool_queue_compare,
				ZBX_BINARY_HEAP_OPTION_DIRECT);
	}

	mediatype->type = type;

	ZBX_UPDATE_STR(mediatype->description, description);
	ZBX_UPDATE_STR(mediatype->smtp_server, smtp_server);
	ZBX_UPDATE_STR(mediatype->smtp_helo, smtp_helo);
	ZBX_UPDATE_STR(mediatype->smtp_email, smtp_email);
	ZBX_UPDATE_STR(mediatype->exec_path, exec_path);
	ZBX_UPDATE_STR(mediatype->exec_params, exec_params);
	ZBX_UPDATE_STR(mediatype->gsm_modem, gsm_modem);
	ZBX_UPDATE_STR(mediatype->username, username);
	ZBX_UPDATE_STR(mediatype->passwd, passwd);

	mediatype->smtp_port = smtp_port;
	mediatype->smtp_security = smtp_security;
	mediatype->smtp_verify_peer = smtp_verify_peer;
	mediatype->smtp_verify_host = smtp_verify_host;
	mediatype->smtp_authentication = smtp_authentication;

	mediatype->maxsessions = maxsessions;
	mediatype->maxattempts = maxattempts;
/******************************************************************************
 * *
 *整个代码块的主要目的是：向am管理器的队列中添加媒体类型。当媒介类型位置为ZBX_AM_LOCATION_NOWHERE时，判断是否可以分配新的会话，如果可以，则将媒介类型添加到队列中。如果媒介类型位置已经不是ZBX_AM_LOCATION_NOWHERE，则直接更新队列中的信息。
 ******************************************************************************/
/* 定义一个静态函数，用于向am管理器的队列中添加媒体类型 */
static void am_push_mediatype(zbx_am_t *manager, zbx_am_mediatype_t *mediatype)
{
    /* 定义一个zbx_binary_heap_elem_t类型的变量elem，用于存储媒体类型的信息 */
    zbx_binary_heap_elem_t elem = {mediatype->mediatypeid, mediatype};

    /* 判断媒介类型队列是否为空，如果为空则直接返回 */
    if (SUCCEED == zbx_binary_heap_empty(&mediatype->queue))
        return;

    /* 如果媒介类型的位置为ZBX_AM_LOCATION_NOWHERE，即尚未被分配到任何位置 */
    if (ZBX_AM_LOCATION_NOWHERE == mediatype->location)
    {
        /* 判断媒介类型是否可以分配新的会话，如果可以，则将媒介类型添加到队列中 */
        if (0 == mediatype->maxsessions || mediatype->alerts_num < mediatype->maxsessions)
        {
            zbx_binary_heap_insert(&manager->queue, &elem);
            /* 更新媒介类型的位置为ZBX_AM_LOCATION_QUEUE，表示已添加到队列中 */
            mediatype->location = ZBX_AM_LOCATION_QUEUE;
        }
    }
    /* 如果媒介类型的位置已经不是ZBX_AM_LOCATION_NOWHERE，则直接更新队列中的信息 */
    else
        zbx_binary_heap_update_direct(&manager->queue, &elem);
}

 ******************************************************************************/
static void	am_push_mediatype(zbx_am_t *manager, zbx_am_mediatype_t *mediatype)
{
	zbx_binary_heap_elem_t	elem = {mediatype->mediatypeid, mediatype};

	if (SUCCEED == zbx_binary_heap_empty(&mediatype->queue))
		return;

	if (ZBX_AM_LOCATION_NOWHERE == mediatype->location)
	{
		if (0 == mediatype->maxsessions || mediatype->alerts_num < mediatype->maxsessions)
		{
			zbx_binary_heap_insert(&manager->queue, &elem);
			mediatype->location = ZBX_AM_LOCATION_QUEUE;
		}
	}
	else
		zbx_binary_heap_update_direct(&manager->queue, &elem);
}

/******************************************************************************
 *                                                                            *
 * Function: am_pop_mediatype                                                 *
 *                                                                            *
 * Purpose: gets the next media type from queue                               *
 *                                                                            *
 * Parameters: manager - [IN] the alert manager                               *
 *                                                                            *
 * Return value: The media type object.                                       *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *整个代码块的主要目的是从给定的manager指向的最小堆中弹出一个zbx_am_mediatype类型的元素，并将该元素的location属性设置为ZBX_AM_LOCATION_NOWHERE，然后返回该元素。如果最小堆为空，则返回NULL。
 ******************************************************************************/
// 定义一个静态函数am_pop_mediatype，接收两个参数，一个zbx_am_t类型的指针manager，和一个指向zbx_binary_heap_elem_t类型的指针的指针
static zbx_am_mediatype_t *am_pop_mediatype(zbx_am_t *manager)
{
	// 定义一个zbx_binary_heap_elem_t类型的指针变量elem，用于存储最小堆的最小元素
	zbx_binary_heap_elem_t *elem;
	// 定义一个zbx_am_mediatype_t类型的指针变量mediatype，用于存储最小堆中弹出的元素
	zbx_am_mediatype_t *mediatype;

	// 判断manager指向的堆是否为空，如果为空则返回NULL
	if (FAIL != zbx_binary_heap_empty(&manager->queue))
		return NULL;

	// 查找并获取最小堆中的最小元素
	elem = zbx_binary_heap_find_min(&manager->queue);
	// 将最小元素的数据赋值给mediatype
	mediatype = (zbx_am_mediatype_t *)elem->data;
	// 设置mediatype的location属性为ZBX_AM_LOCATION_NOWHERE
	mediatype->location = ZBX_AM_LOCATION_NOWHERE;

	// 从最小堆中移除最小元素
	zbx_binary_heap_remove_min(&manager->queue);

	// 返回弹出的最小元素mediatype
	return mediatype;
}

/******************************************************************************
 * *
 *整个代码块的主要目的是释放媒体类型（mediatype）的相关资源，包括描述符、SMTP服务器地址、SMTP服务器的HELO字符串、发送邮件的邮箱地址、执行路径、执行参数、GSM调制解调器的MODEM、用户名和密码等。在释放所有资源后，将媒体类型从管理器的媒体类型集合中移除。如果引用计数不为0，则返回失败（FAIL）。
 ******************************************************************************/
// 定义一个静态函数，用于释放媒体类型（mediatype）的相关资源
static int am_release_mediatype(zbx_am_t *manager, zbx_am_mediatype_t *mediatype)
{
    // 检查媒体类型对象的引用计数是否为0，如果不是，则返回失败（FAIL）
    if (0 != --mediatype->refcount)
        return FAIL;

    // 释放媒体类型描述符
    zbx_free(mediatype->description);

    // 释放SMTP服务器地址
    zbx_free(mediatype->smtp_server);

    // 释放SMTP服务器的HELO字符串
    zbx_free(mediatype->smtp_helo);

    // 释放SMTP发送邮件的邮箱地址
    zbx_free(mediatype->smtp_email);

    // 释放执行路径
    zbx_free(mediatype->exec_path);

    // 释放执行参数
    zbx_free(mediatype->exec_params);

    // 释放GSM调制解调器的MODEM
    zbx_free(mediatype->gsm_modem);

    // 释放用户名
    zbx_free(mediatype->username);

    // 释放密码
    zbx_free(mediatype->passwd);

    // 销毁媒体类型队列
    zbx_binary_heap_destroy(&mediatype->queue);

    // 从管理器的媒体类型集合中移除该媒体类型
    zbx_hashset_remove_direct(&manager->mediatypes, mediatype);

    // 返回成功（SUCCEED）
    return SUCCEED;
}

	zbx_free(mediatype->description);
	zbx_free(mediatype->smtp_server);
	zbx_free(mediatype->smtp_helo);
	zbx_free(mediatype->smtp_email);
	zbx_free(mediatype->exec_path);
	zbx_free(mediatype->exec_params);
	zbx_free(mediatype->gsm_modem);
	zbx_free(mediatype->username);
	zbx_free(mediatype->passwd);
	zbx_binary_heap_destroy(&mediatype->queue);
	zbx_hashset_remove_direct(&manager->mediatypes, mediatype);

	return SUCCEED;
}

/******************************************************************************
 *                                                                            *
 * Function: am_calc_alertpoolid                                              *
 *                                                                            *
 * Purpose: calculate alert pool id from event source, object and objectid    *
 *                                                                            *
 * Parameters: source   - [IN] the event source                               *
 *             object   - [IN] the event object type                          *
 *             objectid - [IN] the event objectid                             *
 *                                                                            *
 * Return value: The alert pool id.                                           *
 *                                                                            *
 ******************************************************************************/
static zbx_uint64_t	am_calc_alertpoolid(int source, int object, zbx_uint64_t objectid)
{
	zbx_hash_t	hash;

	hash = ZBX_DEFAULT_UINT64_HASH_FUNC(&objectid);
	hash = ZBX_DEFAULT_UINT64_HASH_ALGO(&source, sizeof(source), hash);
	hash = ZBX_DEFAULT_UINT64_HASH_ALGO(&object, sizeof(object), hash);

	return hash;
}

/******************************************************************************
 *                                                                            *
 * Function: am_get_alertpool                                                 *
 *                                                                            *
 * Purpose: gets alert pool object, creating one if the object with specified *
 *          identifiers was not found                                         *
 *                                                                            *
 * Parameters: manager     - [IN] the alert manager                           *
 *             mediatypeid - [IN] the media type identifier                   *
 *             alertpoolid - [IN] the alert pool identifier                   *
 *                                                                            *
 * Return value: The alert pool object.                                       *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *这块代码的主要目的是用于获取一个 AlertPool 对象。首先，通过传入的 manager、mediatypeid 和 alertpoolid 参数，在 manager->alertpools 哈希表中查找是否有对应的 AlertPool 对象。如果找不到，则创建一个新的 AlertPool 结构，并初始化其相关属性，如二叉堆、位置、引用计数和警告数量等。最后，返回获取到的 AlertPool 对象。
 ******************************************************************************/
// 定义一个静态函数，用于获取一个 AlertPool 对象
static zbx_am_alertpool_t *am_get_alertpool(zbx_am_t *manager, zbx_uint64_t mediatypeid, zbx_uint64_t alertpoolid)
{
	// 定义一个指向 AlertPool 结构的指针，和一个局部变量 alertpool_local
	zbx_am_alertpool_t	*alertpool, alertpool_local;

	// 将 mediatypeid 和 alertpoolid 分别赋值给 alertpool_local 结构的 mediatypeid 和 id 成员
	alertpool_local.mediatypeid = mediatypeid;
	alertpool_local.id = alertpoolid;

	// 在 manager->alertpools 哈希表中查找是否有对应的 AlertPool 对象
	if (NULL == (alertpool = (zbx_am_alertpool_t *)zbx_hashset_search(&manager->alertpools, &alertpool_local)))
	{
		// 如果没有找到对应的 AlertPool 对象，则创建一个新的 AlertPool 结构
		alertpool = (zbx_am_alertpool_t *)zbx_hashset_insert(&manager->alertpools, &alertpool_local,
				sizeof(alertpool_local));

		// 创建一个二叉堆，用于存储 Alert 对象
		zbx_binary_heap_create(&alertpool->queue, am_alert_queue_compare, ZBX_BINARY_HEAP_OPTION_EMPTY);

		// 初始化 AlertPool 的一些属性
		alertpool->location = ZBX_AM_LOCATION_NOWHERE;
		alertpool->refcount = 0;
		alertpool->alerts_num = 0;
	}

	// 返回获取到的 AlertPool 对象
	return alertpool;
}


/******************************************************************************
 *                                                                            *
 * Function: am_push_alertpool                                                *
 *                                                                            *
 * Purpose: pushes alert pool into media type alert pool queue                *
 *                                                                            *
 * Parameters: mediatype - [IN] the media type                                *
 *             alertpool - [IN] the alert pool                                *
 *                                                                            *
 * Comments: The alert pool is inserted into queue only if it was not already *
 *           queued. Otherwise its position in the queue is updated.          *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *整个代码块的主要目的是：向媒介类型对应的警报队列中添加一个新的警报池，如果警报池已经存在于队列中，则更新队列中的警报池信息。
 ******************************************************************************/
// 定义一个静态函数，用于向警报池中添加警报
static void am_push_alertpool(zbx_am_mediatype_t *mediatype, zbx_am_alertpool_t *alertpool)
{
	// 定义一个zbx_binary_heap_elem_t类型的变量elem，用于存储警报池的信息
	zbx_binary_heap_elem_t elem = {alertpool->id, alertpool};

	// 判断警报池的location属性，如果为ZBX_AM_LOCATION_NOWHERE，则表示警报池不存在
	if (ZBX_AM_LOCATION_NOWHERE == alertpool->location)
	{
		// 判断警报池的alerts_num属性，如果为0，则表示警报池为空
		if (0 == alertpool->alerts_num)
		{
			// 将警报池插入到媒介类型对应的队列中
			zbx_binary_heap_insert(&mediatype->queue, &elem);
			// 更新警报池的location属性，将其设置为ZBX_AM_LOCATION_QUEUE，表示警报池已存在于队列中
			alertpool->location = ZBX_AM_LOCATION_QUEUE;
		}
	}
	// 否则，即警报池已存在于队列中，直接更新队列中的警报池信息
	else
		zbx_binary_heap_update_direct(&mediatype->queue, &elem);
}

/******************************************************************************
 * *
 *整个代码块的主要目的是从传入的zbx_am_mediatype类型的对象的队列（zbx_binary_heap）中取出一个最小的 AlertPool 对象，并对该对象进行初始化（将location字段设置为ZBX_AM_LOCATION_NOWHERE），然后将该对象返回。如果队列中没有 AlertPool 对象，则返回NULL。
 ******************************************************************************/
// 定义一个静态函数am_pop_alertpool，接收两个参数，一个是zbx_am_mediatype_t类型的指针，另一个是void类型的指针。
static zbx_am_alertpool_t *am_pop_alertpool(zbx_am_mediatype_t *mediatype, void *data)
{
	// 定义一个zbx_binary_heap_elem_t类型的指针变量elem，用于存放最小堆的最小元素。
	zbx_binary_heap_elem_t *elem;
	// 定义一个zbx_am_alertpool_t类型的指针变量alertpool，用于存放获取到的最小 AlertPool 对象。
	zbx_am_alertpool_t *alertpool;

	// 检查传入的mediatype->queue是否为空，如果为空则返回NULL。
	if (FAIL != zbx_binary_heap_empty(&mediatype->queue))
		return NULL;

	// 查找最小堆的最小元素，并将最小元素的值赋给elem。
	elem = zbx_binary_heap_find_min(&mediatype->queue);
	// 将elem的data字段解引用，将其指向的zbx_am_alertpool_t对象赋给alertpool。
	alertpool = (zbx_am_alertpool_t *)elem->data;
	// 将alertpool的location字段设置为ZBX_AM_LOCATION_NOWHERE。
	alertpool->location = ZBX_AM_LOCATION_NOWHERE;

	// 从最小堆中移除最小元素。
	zbx_binary_heap_remove_min(&mediatype->queue);

	// 返回获取到的 AlertPool 对象。
	return alertpool;
}


	if (FAIL != zbx_binary_heap_empty(&mediatype->queue))
		return NULL;

	elem = zbx_binary_heap_find_min(&mediatype->queue);
	alertpool = (zbx_am_alertpool_t *)elem->data;
	alertpool->location = ZBX_AM_LOCATION_NOWHERE;

	zbx_binary_heap_remove_min(&mediatype->queue);

	return alertpool;
}

/******************************************************************************
 *                                                                            *
 * Function: am_remove_alertpool                                              *
 *                                                                            *
 * Purpose: removes alert pool                                                *
 *                                                                            *
 * Parameters: manager - [IN] the alert manager                               *
 *             alert   - [IN] the alert pool                                  *
 *                                                                            *
 * Return value: SUCCEED - the object was removed                             *
 *               FAIL    - otherwise                                          *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *整个代码块的主要目的是：释放一个已经被使用的alertpool资源。具体步骤如下：
 *
 *1. 检查alertpool的引用计数，如果为0，说明没有其他地方在使用它，可以安全释放。
 *2. 销毁alertpool的队列，队列为不再使用的数据结构。
 *3. 从manager的alertpools哈希表中移除alertpool，表示不再管理这个alertpool。
 *4. 返回SUCCEED，表示释放alertpool成功。
 ******************************************************************************/
// 定义一个C语言函数，名为am_release_alertpool，接收两个参数：zbx_am_t类型的manager和zbx_am_alertpool_t类型的alertpool
static int am_release_alertpool(zbx_am_t *manager, zbx_am_alertpool_t *alertpool)
{
    // 检查alertpool的引用计数是否为0，如果不是，说明还有其他地方在使用它，返回FAIL，表示释放 alertpool 失败
    if (0 != -- alertpool->refcount)
        return FAIL;

    // 销毁alertpool的队列，队列中的元素不再被使用
    zbx_binary_heap_destroy(&alertpool->queue);

    // 从manager的alertpools哈希表中移除alertpool，表示不再管理这个alertpool
    zbx_hashset_remove_direct(&manager->alertpools, alertpool);

    // 返回SUCCEED，表示释放alertpool成功
/******************************************************************************
 * *
 *整个代码块的主要目的是创建一个zbx_am_alert_t类型的结构体实例，并初始化其成员变量，最后返回该实例。这个实例用于存储警报信息，包括警报ID、媒体类型ID、来源、目标、目标ID、发送对象、主题、消息、状态、重试次数和下次发送时间等。
 ******************************************************************************/
// 定义一个函数am_create_alert，接收9个参数，分别表示：alertid、mediatypeid、source、object、objectid、sendto、subject、message、status、retries和nextsend。
static zbx_am_alert_t *am_create_alert(zbx_uint64_t alertid, zbx_uint64_t mediatypeid, int source, int object,
                                         zbx_uint64_t objectid, const char *sendto, const char *subject, const char *message, int status,
                                         int retries, int nextsend)
{
    // 定义一个指向zbx_am_alert_t类型的指针alert，用于存储创建的警报信息。
    zbx_am_alert_t	*alert;

    // 为alert分配内存空间，并初始化其成员变量。
    // 分配的空间大小为zbx_am_alert_t结构体的大小。
    alert = (zbx_am_alert_t *)zbx_malloc(NULL, sizeof(zbx_am_alert_t));
    
    // 设置alert的alertid、mediatypeid、alertpoolid等成员变量。
    alert->alertid = alertid;
    alert->mediatypeid = mediatypeid;
    alert->alertpoolid = am_calc_alertpoolid(source, object, objectid);

    // 复制sendto、subject、message字符串到alert的相应成员变量中。
    // 使用zbx_strdup函数分配内存并复制字符串。
    alert->sendto = zbx_strdup(NULL, sendto);
    alert->subject = zbx_strdup(NULL, subject);
    alert->message = zbx_strdup(NULL, message);

    // 设置alert的status、retries、nextsend等成员变量。
    alert->status = status;
    alert->retries = retries;
    alert->nextsend = nextsend;

    // 返回创建的警报信息指针alert。
    return alert;
}


	alert = (zbx_am_alert_t *)zbx_malloc(NULL, sizeof(zbx_am_alert_t));
	alert->alertid = alertid;
	alert->mediatypeid = mediatypeid;
	alert->alertpoolid = am_calc_alertpoolid(source, object, objectid);

	alert->sendto = zbx_strdup(NULL, sendto);
	alert->subject = zbx_strdup(NULL, subject);
	alert->message = zbx_strdup(NULL, message);
	alert->status = status;
	alert->retries = retries;
	alert->nextsend = nextsend;

	return alert;
}

/******************************************************************************
 *                                                                            *
 * Function: am_alert_free                                                    *
 *                                                                            *
 * Purpose: frees the alert object                                            *
 *                                                                            *
 * Parameters: alert - [IN] the alert object                                  *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * 以下是对这段C语言代码的详细中文注释：
 *
 *
 *
 *这段代码的主要目的是释放一个名为alert的结构体中的所有内存空间。这个函数通过递归地调用free函数，依次释放alert结构体中的sendto、subject、message指针所指向的内存空间，以及alert结构体本身所占用的内存空间。这样做可以确保在程序运行过程中，不再使用已经分配的内存，避免了内存泄漏的问题。
 ******************************************************************************/
static void am_alert_free(zbx_am_alert_t *alert) // 定义一个静态函数，用于释放alert结构体中的内存空间
{
	zbx_free(alert->sendto); // 释放alert结构体中的sendto指针所指向的内存空间
	zbx_free(alert->subject); // 释放alert结构体中的subject指针所指向的内存空间
	zbx_free(alert->message); // 释放alert结构体中的message指针所指向的内存空间
	zbx_free(alert); // 释放alert结构体本身所占用的内存空间
}


/******************************************************************************
 *                                                                            *
 * Function: am_push_alert                                                    *
 *                                                                            *
 * Purpose: pushes alert into alert pool alert queue                          *
 *                                                                            *
 * Parameters: alertpool - [IN] the alert pool                                *
 *             alert     - [IN] the alert                                     *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *这块代码的主要目的是：定义一个静态函数`am_push_alert`，接收两个参数，一个`zbx_am_alertpool_t`类型的指针`alertpool`和一个`zbx_am_alert_t`类型的指针`alert`。通过创建一个`zbx_binary_heap_elem_t`类型的变量`elem`，将其插入到`alertpool`的队列中。这个函数用于将alert对象添加到alertpool中，以便后续处理和处理警报。
 ******************************************************************************/
// 定义一个静态函数，用于向alertpool中的队列插入一个alert元素
static void am_push_alert(zbx_am_alertpool_t *alertpool, zbx_am_alert_t *alert)
{
    // 定义一个zbx_binary_heap_elem_t类型的变量elem，用于存储alert元素
    zbx_binary_heap_elem_t elem = {0, alert};

/******************************************************************************
 * *
 *整个代码块的主要目的是从zbx_am_t类型的指针manager中获取一个zbx_am_alert_t类型的指针。首先，通过am_pop_mediatype获取到对应的zbx_am_mediatype，然后通过am_pop_alertpool获取到alertpool。接着在alertpool的队列中查找最小值的元素，将其指向的alert赋值给alert。最后，如果没有达到并行警报的最大数量，将mediatype重新入队，并返回获取到的alert。
 ******************************************************************************/
/* 定义一个函数am_pop_alert，接收一个zbx_am_t类型的指针manager作为参数，返回一个指向zbx_am_alert_t类型的指针。
*/
static zbx_am_alert_t *am_pop_alert(zbx_am_t *manager)
{
	/* 定义三个指向zbx_am_mediatype_t类型的指针，分别为mediatype、alertpool和alert，以及一个zbx_binary_heap_elem_t类型的指针elem。
	*/
	zbx_am_mediatype_t	*mediatype;
	zbx_am_alertpool_t	*alertpool;
	zbx_am_alert_t		*alert;
	zbx_binary_heap_elem_t	*elem;

	/* 如果从manager中获取mediatype失败，返回NULL。
	*/
	if (NULL == (mediatype = am_pop_mediatype(manager)))
		return NULL;

	/* 使用mediatype获取对应的alertpool。
	*/
	alertpool = am_pop_alertpool(mediatype);

	/* 在alertpool的队列中查找最小值的元素，将其指向的alert赋值给alert。
	*/
	elem = zbx_binary_heap_find_min(&alertpool->queue);
	alert = (zbx_am_alert_t *)elem->data;
	zbx_binary_heap_remove_min(&alertpool->queue);

	/* 如果没有达到并行警报的最大数量，将mediatype重新入队。
	*/
	mediatype->alerts_num++;
	alertpool->alerts_num++;
	if (0 == mediatype->maxsessions || mediatype->alerts_num < mediatype->maxsessions)
		am_push_mediatype(manager, mediatype);

	/* 返回获取到的alert。
	*/
	return alert;
}

		return NULL;

	alertpool = am_pop_alertpool(mediatype);

	elem = zbx_binary_heap_find_min(&alertpool->queue);
	alert = (zbx_am_alert_t *)elem->data;
	zbx_binary_heap_remove_min(&alertpool->queue);

	/* requeue media type if the number of parallel alerts has not yet reached */
	mediatype->alerts_num++;
	alertpool->alerts_num++;
	if (0 == mediatype->maxsessions || mediatype->alerts_num < mediatype->maxsessions)
		am_push_mediatype(manager, mediatype);

	return alert;
}

/******************************************************************************
 *                                                                            *
 * Function: am_remove_alert                                                  *
 *                                                                            *
 * Purpose: removes alert and requeues associated alert pool and media type   *
 *                                                                            *
 * Parameters: manager - [IN] the alert manager                               *
 *             alert   - [IN] the alert                                       *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *这块代码的主要目的是删除一个 Alert 对象。函数 `am_remove_alert` 接收两个参数，一个是 Alert 管理器（manager）指针，另一个是待删除的 Alert 对象指针。在函数内部，首先根据 Alert 的媒体类型 ID 获取媒体类型对象，然后判断媒体类型是否存在。如果存在，则减少媒体类型的 Alert 数量。接着，根据 Alert 的媒体类型 ID 和 Alert 池 ID 获取 Alert 池对象，判断 Alert 池是否存在。如果存在，则减少 Alert 池的 Alert 数量。最后，调用 `am_release_mediatype` 函数释放媒体类型对象，如果释放失败，则将媒体类型推入队列。同时，释放待删除的 Alert 对象。
 ******************************************************************************/
// 定义一个静态函数，用于移除一个 Alert
static void am_remove_alert(zbx_am_t *manager, zbx_am_alert_t *alert)
{
	// 声明一个指向 Alert 池的指针
	zbx_am_alertpool_t	*alertpool;
	// 声明一个指向媒体类型的指针
	zbx_am_mediatype_t	*mediatype;

	// 判断 alert 的媒体类型是否存在，如果不为空，则进行以下操作
	if (NULL != (mediatype = am_get_mediatype(manager, alert->mediatypeid)))
	{
		// 媒体类型的 Alert 数量减一
		mediatype->alerts_num--;

		// 判断 alert 所在的 Alert 池是否存在，如果不为空，则进行以下操作
		if (NULL != (alertpool = am_get_alertpool(manager, alert->mediatypeid, alert->alertpoolid)))
		{
/******************************************************************************
 * *
 *整个代码块的主要目的是处理 alert，根据 alert 的重试次数和媒体类型（mediatype）的最大重试次数来判断是否需要继续重试发送 alert。如果重试次数未达到最大次数，则更新 alert 的 nextsend 时间，并将 alert 推入 alert pool 等待再次发送。同时，将 alert pool 推入媒体类型（mediatype）的 alert pools 列表，并更新媒体类型（mediatype）的 alerts_num 计数。如果重试次数达到最大次数，则表示重试失败，不再发送 alert。函数执行结束后，返回执行结果。
 ******************************************************************************/
// 定义一个名为 am_retry_alert 的静态函数，参数分别为 zbx_am_t 类型的指针 manager 和 zbx_am_alert_t 类型的指针 alert。
static int	am_retry_alert(zbx_am_t *manager, zbx_am_alert_t *alert)
{
	// 定义一个常量字符串，表示函数名
	const char		*__function_name = "am_retry_alert";

	// 声明一个 zbx_am_alertpool_t 类型的指针 alertpool，用于存储 alert 所属的 alert pool。
	zbx_am_alertpool_t	*alertpool;

	// 声明一个 zbx_am_mediatype_t 类型的指针 mediatype，用于存储 alert 所属的媒体类型。
	zbx_am_mediatype_t	*mediatype;

	// 定义一个整型变量 ret，初始值为 FAIL，用于存储函数执行结果。
	int			ret = FAIL;

	// 记录日志，表示进入函数，输出 alert 的 id。
	zabbix_log(LOG_LEVEL_DEBUG, "In %s() alertid:" ZBX_FS_UI64, __function_name, alert->alertid);

	// 从 manager 获取 media type，如果为空，则表示获取失败，跳转到 out 标签处。
	if (NULL == (mediatype = am_get_mediatype(manager, alert->mediatypeid)))
		goto out;

	// 如果 alert 的重试次数（retries）加一后大于等于媒体类型（mediatype）的最大重试次数，则表示重试次数已用完，跳转到 out 标签处。
	if (++alert->retries >= mediatype->maxattempts)
		goto out;

	// 更新 alert 的 nextsend 时间为当前时间加上媒体类型（mediatype）的尝试间隔。
	alert->nextsend = time(NULL) + mediatype->attempt_interval;

	// 从 manager 获取 alert pool，用于存储 alert。
	alertpool = am_get_alertpool(manager, alert->mediatypeid, alert->alertpoolid);

	// 减一计数，表示 alert 已被处理。
	mediatype->alerts_num--;
	alertpool->alerts_num--;

	// 将 alert 推入 alert pool。
	am_push_alert(alertpool, alert);

	// 将 alert pool 推入媒体类型（mediatype）的 alert pools 列表。
	am_push_alertpool(mediatype, alertpool);

	// 将媒体类型（mediatype）推入 manager 的媒体类型（mediatype）列表。
	am_push_mediatype(manager, mediatype);

	// 更新函数执行结果为 SUCCEED。
	ret = SUCCEED;
out:
	// 记录日志，表示函数执行结束。
	zabbix_log(LOG_LEVEL_DEBUG, "End of %s()", __function_name);

	// 返回函数执行结果。
	return ret;
}

	zbx_am_mediatype_t	*mediatype;
	int			ret = FAIL;

	zabbix_log(LOG_LEVEL_DEBUG, "In %s() alertid:" ZBX_FS_UI64, __function_name, alert->alertid);

	if (NULL == (mediatype = am_get_mediatype(manager, alert->mediatypeid)))
		goto out;

	if (++alert->retries >= mediatype->maxattempts)
		goto out;

	alert->nextsend = time(NULL) + mediatype->attempt_interval;

	alertpool = am_get_alertpool(manager, alert->mediatypeid, alert->alertpoolid);

	mediatype->alerts_num--;
	alertpool->alerts_num--;

	am_push_alert(alertpool, alert);
	am_push_alertpool(mediatype, alertpool);
	am_push_mediatype(manager, mediatype);

	ret = SUCCEED;
out:
	zabbix_log(LOG_LEVEL_DEBUG, "End of %s()", __function_name);

	return ret;
}

/******************************************************************************
 *                                                                            *
 * Function: am_alerter_free                                                  *
 *                                                                            *
 * Purpose: frees alerter                                                     *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *整个代码块的主要目的是：释放alerter资源。具体来说，就是关闭alerter的IPC客户端，并释放alerter所占用的内存空间。
 ******************************************************************************/
// 定义一个静态函数，用于释放alerter资源
static void am_alerter_free(zbx_am_alerter_t *alerter)
{
	// 关闭alerter的IPC客户端
	zbx_ipc_client_close(alerter->client);

	// 释放alerter内存空间
	zbx_free(alerter);
}


/******************************************************************************
 *                                                                            *
 * Function: am_register_alerter                                              *
/******************************************************************************
 * *
 *整个代码块的主要目的是处理客户端连接，判断连接进程是否为本地进程，如果是本地进程，则将alerter（报警器）注册到manager（管理者）中，并将alerter插入到alerters_client（客户端报警器）哈希集中。最后将alerter推入free_alerters（自由报警器）队列。如果不是本地进程，则关闭客户端连接并拒绝连接。
 ******************************************************************************/
// 定义静态函数am_register_alerter，接收3个参数：zbx_am_t类型的manager，zbx_ipc_client_t类型的client，以及zbx_ipc_message_t类型的message
static void am_register_alerter(zbx_am_t *manager, zbx_ipc_client_t *client, zbx_ipc_message_t *message)
{
	// 定义常量字符串，表示函数名
	const char *__function_name = "am_register_alerter";
	// 定义alerter指针，如果alerter类型发生变化，不要忘记更改sizeof()
	zbx_am_alerter_t *alerter = NULL;
	// 定义进程父进程ID（ppid）
	pid_t ppid;

	// 打印调试日志，表示进入该函数
	zabbix_log(LOG_LEVEL_DEBUG, "In %s()", __function_name);

	// 从message数据中复制ppid到本地变量ppid
	memcpy(&ppid, message->data, sizeof(ppid));

	// 如果ppid不等于当前进程的父进程ID
	if (ppid != getppid())
	{
		// 关闭客户端连接，并打印拒绝连接的日志
		zbx_ipc_client_close(client);
		zabbix_log(LOG_LEVEL_DEBUG, "refusing connection from foreign process");
	}
	else
	{
		// 如果manager的下一个alerter索引等于alerter数量
		if (manager->next_alerter_index == manager->alerters.values_num)
		{
			// 表示不应该发生的情况，退出程序
			THIS_SHOULD_NEVER_HAPPEN;
			exit(EXIT_FAILURE);
		}

		// 获取下一个alerter指针
		alerter = (zbx_am_alerter_t *)manager->alerters.values[manager->next_alerter_index++];
		alerter->client = client;

		// 将alerter插入到manager的alerters_client哈希集中
		zbx_hashset_insert(&manager->alerters_client, &alerter, sizeof(zbx_am_alerter_t *));
		// 将alerter推入manager的free_alerters队列
		zbx_queue_ptr_push(&manager->free_alerters, alerter);
	}

	// 打印调试日志，表示函数结束
	zabbix_log(LOG_LEVEL_DEBUG, "End of %s()", __function_name);
}

		/* sizeof(zbx_am_alerter_t *) in the following line returns size of 'alerter' pointer. */
		/* sizeof(alerter) is not used to avoid analyzer warning */
		zbx_hashset_insert(&manager->alerters_client, &alerter, sizeof(zbx_am_alerter_t *));
		zbx_queue_ptr_push(&manager->free_alerters, alerter);
	}

	zabbix_log(LOG_LEVEL_DEBUG, "End of %s()", __function_name);
}

/******************************************************************************
 *                                                                            *
 * Function: am_get_alerter_by_client                                         *
 *                                                                            *
 * Purpose: returns alerter by connected client                               *
 *                                                                            *
 * Parameters: manager - [IN] the manager                                     *
 *             client  - [IN] the connected alerter                           *
 *                                                                            *
 * Return value: The IPMI poller                                              *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *这块代码的主要目的是根据传入的manager和client指针，在manager的alerters_client哈希集中查找对应的alerter指针，并返回找到的alerter。如果在哈希集中找不到对应的alerter，则会退出程序，表示发生错误。
 ******************************************************************************/
// 定义一个静态局部变量，用于存储alerter指针
static zbx_am_alerter_t	*am_get_alerter_by_client(zbx_am_t *manager, zbx_ipc_client_t *client)
{
	// 定义一个alerter指针的指针，以及一个本地变量alerter_local
	zbx_am_alerter_t	**alerter, alerter_local, *plocal = &alerter_local;

	// 将client指针赋值给plocal的client成员
	plocal->client = client;
/******************************************************************************
 * *
 *整个代码块的主要目的是生成一个数据库报警信息字符串。这个函数接收一个空参数，返回一个字符串。在函数内部，首先定义了一些字符串和变量，然后使用zbx_snprintf_alloc函数根据配置信息生成报警信息，最后将生成的报警信息返回。如果数据库连接失败，还会添加相应的错误信息。
 ******************************************************************************/
// 定义一个静态字符指针，用于存储数据库报警信息
static char *am_create_db_alert_message(void);

// 函数am_create_db_alert_message的实现，用于生成数据库报警信息
{
	// 定义一个常量字符指针error，用于存储错误信息
	const char *error;
	// 定义一个字符指针alert_message，初始化为NULL
	char *alert_message = NULL;
	// 定义两个size_t类型的变量，分别用于存储alert_message的长度和分配空间
	size_t alert_message_alloc = 0, alert_message_offset = 0;

	// 使用zbx_snprintf_alloc函数生成报警信息，参数分别为：
	// alert_message：存储报警信息的字符指针
	// alert_message_alloc：alert_message的分配空间
	// alert_message_offset：alert_message的偏移量
	// 格式化字符串："%s database \"%s\""，其中的%s和%d分别用ZBX_DATABASE_TYPE和CONFIG_DBNAME替换
	zbx_snprintf_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, "%s database \"%s\"",
			ZBX_DATABASE_TYPE, CONFIG_DBNAME);

	// 如果CONFIG_DBHOST不为空字符串
	if ('\0' != *CONFIG_DBHOST)
	{
		// 使用zbx_snprintf_alloc函数生成报警信息，参数分别为：
		// alert_message：存储报警信息的字符指针
		// alert_message_alloc：alert_message的分配空间
		// alert_message_offset：alert_message的偏移量
		// 格式化字符串：" on \"%s"
		zbx_snprintf_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, " on \"%s",
				CONFIG_DBHOST);

		// 如果CONFIG_DBPORT不为0
		if (0 != CONFIG_DBPORT)
		{
			// 使用zbx_snprintf_alloc函数生成报警信息，参数分别为：
			// alert_message：存储报警信息的字符指针
			// alert_message_alloc：alert_message的分配空间
			// alert_message_offset：alert_message的偏移量
			// 格式化字符串：":%d\"
			zbx_snprintf_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, ":%d\"",
					CONFIG_DBPORT);
		}
		// 否则，将空字符串赋值给alert_message的最后一个字符
		else
			zbx_chrcpy_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, '\"');
	}

	// 使用zbx_snprintf_alloc函数生成报警信息，参数分别为：
	// alert_message：存储报警信息的字符指针
	// alert_message_alloc：alert_message的分配空间
	// alert_message_offset：alert_message的偏移量
	// 格式化字符串：" is not available"
	zbx_snprintf_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, " is not available");

	// 如果zbx_db_last_strerr()不为空且不为空字符串，则添加错误信息
	if (NULL != (error = zbx_db_last_strerr()) && '\0' != *error)
	{
		// 使用zbx_snprintf_alloc函数生成报警信息，参数分别为：
		// alert_message：存储报警信息的字符指针
		// alert_message_alloc：alert_message的分配空间
		// alert_message_offset：alert_message的偏移量
		// 格式化字符串："： %s"，其中的%s用error替换
		zbx_snprintf_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, ": %s", error);
	}

	// 返回生成的报警信息
	return alert_message;
}

 *                                                                            *
 * Purpose: get and format error message from database when it is unavailable *
 *                                                                            *
 * Return value: full database error message is allocated                     *
 *                                                                            *
 ******************************************************************************/
static char	*am_create_db_alert_message(void)
{
	const char	*error;
	char		*alert_message = NULL;
	size_t		alert_message_alloc = 0, alert_message_offset = 0;

	zbx_snprintf_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, "%s database \"%s\"",
			ZBX_DATABASE_TYPE, CONFIG_DBNAME);

	if ('\0' != *CONFIG_DBHOST)
	{
		zbx_snprintf_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, " on \"%s",
				CONFIG_DBHOST);

		if (0 != CONFIG_DBPORT)
		{
			zbx_snprintf_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, ":%d\"",
					CONFIG_DBPORT);
		}
		else
			zbx_chrcpy_alloc(&alert_message, &alert_message_alloc, &alert_message_offset, '\"');
	}
/******************************************************************************
 * *
 *整个代码块的主要目的是检查zbx_am_t结构中的watchdog成员（表示监控dog）的媒体类型，并为每个媒体类型创建一个警报。创建的警报会根据媒体类型的信息进行发送。在这个过程中，还记录了日志和更新了上次发送警报的时间。
 ******************************************************************************/
static void am_queue_watchdog_alerts(zbx_am_t *manager)
{
    // 定义一个常量字符串，表示函数名
    const char *__function_name = "am_queue_watchdog_alerts";

    // 定义一个静态变量，表示最后一次发送警报的时间
    static int lastsent;

    // 定义一个整型变量，表示当前时间
    int now;

    // 定义一个指向zbx_am_media_t结构的指针，用于遍历媒体类型
    zbx_am_media_t *media;

    // 定义一个指向zbx_am_mediatype_t结构的指针，用于遍历媒体类型
    zbx_am_mediatype_t *mediatype;

    // 定义一个指向zbx_am_alertpool_t结构的指针，用于遍历警报池
    zbx_am_alertpool_t *alertpool;

    // 定义一个指向zbx_am_alert_t结构的指针，用于创建警报
    zbx_am_alert_t *alert;

    // 定义一个指向zbx_hashset_iter_t结构的指针，用于遍历媒体类型
    zbx_hashset_iter_t iter;

    // 定义一个常量字符串，表示警报主题
    const char *alert_subject = "Zabbix database is not available.";

    // 定义一个字符串变量，用于存储警报信息
    char *alert_message;

    // 判断当前时间是否小于上次发送警报时间加上警报发送频率，如果是，则直接返回
    if ((now = time(NULL)) < lastsent + ZBX_WATCHDOG_ALERT_FREQUENCY)
        return;

    // 记录日志，表示DEBUG级别，输出函数名和接收者数量
    zabbix_log(LOG_LEVEL_DEBUG, "%s() recipients:%d", __function_name, manager->watchdog.num_data);

    // 重置遍历指针，用于重新遍历媒体类型
    zbx_hashset_iter_reset(&manager->watchdog, &iter);

    // 遍历媒体类型，直到遍历结束
    while (NULL != (media = (zbx_am_media_t *)zbx_hashset_iter_next(&iter)))
    {
        // 如果未找到对应的媒体类型，则跳过本次循环
        if (NULL == (mediatype = am_get_mediatype(manager, media->mediatypeid)))
            continue;

        // 增加媒体类型的引用计数
        mediatype->refcount++;

        // 创建警报信息
        alert_message = am_create_db_alert_message();

        // 创建警报，并设置媒体类型、警报主题和警报信息
        alert = am_create_alert(0, media->mediatypeid, 0, 0, 0, media->sendto, alert_subject, alert_message, 0,
                               0, 0);

        // 获取对应的警报池，并增加引用计数
        alertpool = am_get_alertpool(manager, alert->mediatypeid, alert->alertpoolid);
        alertpool->refcount++;

        // 将警报压入警报池
        am_push_alert(alertpool, alert);

        // 将警报池压入媒体类型的警报池队列
        am_push_alertpool(mediatype, alertpool);

        // 将媒体类型压入管理器的媒体类型队列
        am_push_mediatype(manager, mediatype);

        // 释放警报信息
        zbx_free(alert_message);
    }

    // 更新上次发送警报时间
    lastsent = now;
}


		mediatype->refcount++;

		alert_message = am_create_db_alert_message();

		alert = am_create_alert(0, media->mediatypeid, 0, 0, 0, media->sendto, alert_subject, alert_message, 0,
				0, 0);

		alertpool = am_get_alertpool(manager, alert->mediatypeid, alert->alertpoolid);
		alertpool->refcount++;

		am_push_alert(alertpool, alert);
		am_push_alertpool(mediatype, alertpool);
		am_push_mediatype(manager, mediatype);

		zbx_free(alert_message);
	}

	lastsent = now;
}

/******************************************************************************
 *                                                                            *
 * Function: am_init                                                          *
 *                                                                            *
 * Purpose: initializes alert manager                                         *
 *                                                                            *
 * Parameters: manager - [IN] the manager to initialize                       *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *整个代码块的主要目的是初始化一个alerter管理器（`zbx_am_t`）实例。在这个过程中，创建了多个alerter实例，并设置了相应的哈希集、队列等数据结构，以便在后续的处理警报任务时使用。此外，还记录了日志，以显示函数的执行过程。
 ******************************************************************************/
static void am_init(zbx_am_t *manager)
{
	// 定义一个常量字符串，表示函数名
	const char *__function_name = "am_init";
	int i;
	zbx_am_alerter_t *alerter;

	// 记录日志，显示当前函数名和配置的alerter进程数
	zabbix_log(LOG_LEVEL_DEBUG, "In %s() alerters:%d", __function_name, CONFIG_ALERTER_FORKS);

	// 创建一个指向alerter的指针数组，用于存储多个alerter实例
	zbx_vector_ptr_create(&manager->alerters);

	// 创建一个自由alerter列表，用于存储空闲的alerter实例
	zbx_queue_ptr_create(&manager->free_alerters);

	// 创建一个alerter客户端的哈希集，用于存储alerter实例及其对应的客户端
	zbx_hashset_create(&manager->alerters_client, 0, alerter_hash_func, alerter_compare_func);

	// 设置下一个alerter的索引
	manager->next_alerter_index = 0;

	// 循环创建alerter实例，直到达到配置的alerter进程数
	for (i = 0; i < CONFIG_ALERTER_FORKS; i++)
	{
		alerter = (zbx_am_alerter_t *)zbx_malloc(NULL, sizeof(zbx_am_alerter_t));

		// 初始化alerter实例，将其客户端指针设置为空
		alerter->client = NULL;

		// 将alerter添加到alerters数组中
		zbx_vector_ptr_append(&manager->alerters, alerter);
	}

	// 创建一些哈希集，用于存储不同的数据类型
	zbx_hashset_create(&manager->mediatypes, 5, ZBX_DEFAULT_UINT64_HASH_FUNC, ZBX_DEFAULT_UINT64_COMPARE_FUNC);
	zbx_hashset_create(&manager->alertpools, 100, am_alertpool_hash_func, am_alertpool_compare_func);
	zbx_hashset_create(&manager->alertupdates, 100, ZBX_DEFAULT_UINT64_HASH_FUNC, ZBX_DEFAULT_UINT64_COMPARE_FUNC);
	zbx_hashset_create(&manager->watchdog, 5, ZBX_DEFAULT_UINT64_HASH_FUNC, ZBX_DEFAULT_UINT64_COMPARE_FUNC);

	// 创建一个优先级队列，用于存储媒体类型
	zbx_binary_heap_create(&manager->queue, am_mediatype_queue_compare, ZBX_BINARY_HEAP_OPTION_DIRECT);

	// 记录日志，显示函数执行完毕
	zabbix_log(LOG_LEVEL_DEBUG, "End of %s()", __function_name);
}


/******************************************************************************
 *                                                                            *
 * Function: am_destroy                                                       *
 *                                                                            *
 * Purpose: destroys alert manager                                            *
 *                                                                            *
 * Parameters: manager - [IN] the manager to destroy                          *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *整个代码块的主要目的是销毁一个警报管理器（am）对象，其中包括清理与管理器关联的各类数据结构，如哈希集、队列、vector等，以及释放各类对象的内存资源。
 ******************************************************************************/
static void	am_destroy(zbx_am_t *manager)
{	// 定义一个函数，用于销毁am（警报管理器）对象

	zbx_am_alert_t		*alert;	// 定义一个指向警报对象的指针
	zbx_hashset_iter_t	iter;	// 定义一个哈希集迭代器
	zbx_am_media_t		*media;	// 定义一个指向媒体对象的指针

	zbx_hashset_destroy(&manager->alerters_client);	// 销毁与管理器关联的警报客户端哈希集
	zbx_queue_ptr_destroy(&manager->free_alerters);	// 销毁与管理器关联的免费警报队列
	zbx_vector_ptr_clear_ext(&manager->alerters, (zbx_mem_free_func_t)am_alerter_free);	// 清理与管理器关联的警报 vector，并使用 am_alerter_free 函数释放内存
	zbx_vector_ptr_destroy(&manager->alerters);	// 销毁与管理器关联的警报 vector

	while (NULL != (alert = am_pop_alert(manager)))	// 循环从管理器的警报队列中取出警报对象
		am_remove_alert(manager, alert);	// 移除警报对象

	zbx_binary_heap_destroy(&manager->queue);	// 销毁与管理器关联的二叉堆（用于存储警报）

	zbx_hashset_iter_reset(&manager->watchdog, &iter);	// 重置与管理器关联的监视dog哈希集的迭代器
	while (NULL != (media = (zbx_am_media_t *)zbx_hashset_iter_next(&iter)))	// 遍历与管理器关联的媒体对象
	{
		zbx_free(media->sendto);	// 释放媒体对象的发送地址内存
		zbx_hashset_iter_remove(&iter);	// 移除当前媒体对象
	}
	zbx_hashset_destroy(&manager->watchdog);	// 销毁与管理器关联的监视dog哈希集

	zbx_hashset_destroy(&manager->alertupdates);	// 销毁与管理器关联的警报更新哈希集
	zbx_hashset_destroy(&manager->alertpools);	// 销毁与管理器关联的警报池哈希集
	zbx_hashset_destroy(&manager->mediatypes);	// 销毁与管理器关联的媒体类型哈希集
}


/******************************************************************************
 *                                                                            *
 * Function: am_db_update_alert                                               *
 *                                                                            *
 * Purpose: update alert status in local cache to be flushed after reading    *
 *          new alerts from database                                          *
 *                                                                            *
 * Parameters: manager - [IN] the manager                                     *
 *             alertid - [IN] the alert identifier                            *
 *             status  - [IN] the alert status                                *
 *             retries - [IN] the number of attempted sending retries         *
 *             error   - [IN] the error message                               *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *整个代码块的主要目的是用于更新数据库中的警报状态。函数`am_db_update_alert`接收5个参数，分别是警报管理器`manager`、警报ID`alertid`、状态`status`、重试次数`retries`和错误信息`error`。在函数中，首先判断警报ID是否为0，如果不为0，则表示是一条有效的警报。然后在新建的`zbx_am_alertstatus_t`结构体中更新警报的`retries`次数和`status`状态，并插入到警报管理器的`manager->alertupdates`哈希表中。同时，更新警报的`error`信息。最后，记录日志表示函数执行完毕。
 ******************************************************************************/
/* 定义一个静态函数，用于更新数据库中的警报状态 */
static void am_db_update_alert(zbx_am_t *manager, zbx_uint64_t alertid, int status, int retries, char *error)
{
	/* 定义一个字符串，用于存储函数名 */
	const char *__function_name = "am_db_update_alert";

	/* 定义一个指针，用于指向zbx_am_alertstatus_t结构体 */
	zbx_am_alertstatus_t *update;

	/* 记录日志，表示函数开始执行 */
	zabbix_log(LOG_LEVEL_DEBUG, "In %s() alertid:" ZBX_FS_UI64 " status:%d retries:%d error:%s", __function_name,
			alertid, status, retries, error);

	/* 判断alertid是否不为0，如果不为0，则表示是一条有效的警报 */
	if (0 != alertid)
	{
		/* 如果在manager->alertupdates哈希表中找不到该警报，则新建一个警报 */
		if (NULL == (update = (zbx_am_alertstatus_t *)zbx_hashset_search(&manager->alertupdates, &alertid)))
		{
			/* 初始化一个新的zbx_am_alertstatus_t结构体 */
			zbx_am_alertstatus_t	update_local = {.alertid = alertid};

			/* 将新的警报插入到manager->alertupdates哈希表中 */
			update = (zbx_am_alertstatus_t *)zbx_hashset_insert(&manager->alertupdates, &update_local,
					sizeof(update_local));
		}

		/* 更新警报的retries次数和status状态 */
		update->retries = retries;
		update->status = status;

		/* 更新警报的error信息 */
		ZBX_UPDATE_STR(update->error, error);
	}

	/* 记录日志，表示函数执行完毕 */
	zabbix_log(LOG_LEVEL_DEBUG, "End of %s()", __function_name);
}


/******************************************************************************
 *                                                                            *
 * Function: am_db_get_alerts                                                 *
 *                                                                            *
 * Purpose: reads the new alerts from database                                *
 *                                                                            *
 * Parameters: alerts - [OUT] the new alerts                                  *
 *             now    - [IN] the current timestamp                            *
 *                                                                            *
 * Comments: One the first call this function will return new and not sent    *
 *           alerts. After that only new alerts are returned.                 *
 *                                                                            *
 * Return value: SUCCEED - the alerts were read successfully                  *
 *               FAIL    - database connection error                          *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *整个代码块的主要目的是从数据库中查询符合条件的警报（alert），并将符合条件的警报添加到`alerts`向量中。具体来说，这段代码实现了以下功能：
 *
 *1. 定义了静态变量`status_limit`和状态过滤器`status_filter`。
 *2. 初始化`alertids`向量。
 *3. 构造SQL查询语句，并添加状态过滤条件。
 *4. 执行SQL查询，获取查询结果。
 *5. 遍历查询结果，解析alertid、mediatypeid、status等字段。
 *6. 创建alert对象并添加到`alerts`向量中。
 *7. 如果alert状态为NEW，将其alertid添加到`alertids`向量中。
 *8. 如果`alertids`向量不为空，更新alert状态为NOT_SENT。
 *9. 释放内存并结束。
 *10. 返回操作结果。
 ******************************************************************************/
// 定义静态变量，用于存储状态限制和过滤器
static int		status_limit = 2;
zbx_uint64_t		status_filter[] = {ALERT_STATUS_NEW, ALERT_STATUS_NOT_SENT};

// 定义函数名
const char		*__function_name = "am_db_get_alerts";

// 初始化alertids向量
zbx_vector_uint64_create(&alertids);

// 构造SQL查询语句
zbx_snprintf_alloc(&sql, &sql_alloc, &sql_offset,
		"select a.alertid,a.mediatypeid,a.sendto,a.subject,a.message,a.status,a.retries,"
			"e.source,e.object,e.objectid"
		" from alerts a"
		" left join events e"
			" on a.eventid=e.eventid"
		" where alerttype=%d"
		" and",
		ALERT_TYPE_MESSAGE);

// 添加状态过滤条件
DBadd_condition_alloc(&sql, &sql_alloc, &sql_offset, "a.status", status_filter, status_limit);
zbx_strcpy_alloc(&sql, &sql_alloc, &sql_offset, " order by a.alertid");

// 执行SQL查询
result = DBselect_once("%s", sql);

// 检查查询结果是否有效，如果无效，返回失败
if (NULL == result || (DB_RESULT)ZBX_DB_DOWN == result)
{
	ret = FAIL;
	goto out;
}

// 遍历查询结果
while (NULL != (row = DBfetch(result)))
{
	// 解析alertid、mediatypeid、status等字段
	ZBX_STR2UINT64(alertid, row[0]);
	ZBX_STR2UINT64(mediatypeid, row[1]);
	status = atoi(row[5]);
	attempts = atoi(row[6]);

	// 如果相关事件已被移除，更新alert状态
	if (SUCCEED == DBis_null(row[7]))
	{
		am_db_update_alert(manager, alertid, ALERT_STATUS_FAILED, 0,
				(char *)"Related event was removed.");
		continue;
	}

	// 解析source、object、objectid等字段
	source = atoi(row[7]);
	object = atoi(row[8]);
	ZBX_STR2UINT64(objectid, row[9]);

	// 创建alert对象并添加到alerts向量中
	alert = am_create_alert(alertid, mediatypeid, source, object, objectid, row[2], row[3], row[4],
			status, attempts, now);

	zbx_vector_ptr_append(alerts, alert);

	// 如果alert状态为NEW，将其alertid添加到alertids向量中
	if (ALERT_STATUS_NEW == alert->status)
		zbx_vector_uint64_append(&alertids, alert->alertid);
}
DBfree_result(result);

// 如果alertids向量不为空，更新alert状态为NOT_SENT
if (0 != alertids.values_num)
{
	sql_offset = 0;
	zbx_snprintf_alloc(&sql, &sql_alloc, &sql_offset, "update alerts set status=%d where",
			ALERT_STATUS_NOT_SENT);
	DBadd_condition_alloc(&sql, &sql_alloc, &sql_offset, "alertid", alertids.values, alertids.values_num);

	// 执行SQL更新语句
	if (ZBX_DB_DOWN == DBexecute_once("%s", sql))
	{
		// 如果更新失败，释放alerts向量中的内存并返回失败
		zbx_vector_ptr_clear_ext(alerts, (zbx_mem_free_func_t)am_alert_free);
		ret = FAIL;
	}
}

// 释放内存并结束
zbx_vector_uint64_destroy(&alertids);

// 如果操作成功，更新状态限制
if (SUCCEED == ret)
	status_limit = 1;

// 返回结果
goto out;

/******************************************************************************
 * *
 *这段代码的主要目的是更新媒体类型数据库。它接收一个媒体类型管理器指针、一个媒体类型ID数组和媒体类型ID的数量，然后根据给定的媒体类型ID查询数据库中的媒体类型信息，并对查询结果进行处理和更新。具体来说，代码实现了以下功能：
 *
 *1. 定义了一些变量，用于存储查询结果和更新数据。
 *2. 打印调试信息，表示进入函数。
 *3. 判断媒体类型数量是否为0，如果为0则直接退出。
 *4. 构造查询语句，从数据库中获取媒体类型信息。
 *5. 添加查询条件，根据媒体类型ID进行筛选。
 *6. 执行查询语句，查询媒体类型信息。
 *7. 遍历查询结果，解析媒体类型ID、类型、SMTP安全设置、SMTP验证等参数。
 *8. 检查并更新尝试间隔。
 *9. 更新媒体类型信息。
 *10. 释放查询结果。
 *11. 打印调试信息，表示函数执行结束。
 *12. 返回更新结果。
 ******************************************************************************/
// 定义一个静态函数，用于更新媒体类型数据库
static int am_db_update_mediatypes(zbx_am_t *manager, const zbx_uint64_t *mediatypeids, int mediatypeids_num)
{
	// 定义一些变量，用于存储查询结果和更新数据
	const char *__function_name = "am_db_update_mediatypes";
	DB_RESULT result;
	DB_ROW row;
	char *sql = NULL;
	size_t sql_alloc = 0, sql_offset = 0;
	int type, maxsessions, maxattempts, attempt_interval, ret = SUCCEED;
	zbx_uint64_t mediatypeid;
	unsigned short smtp_port;
	unsigned char smtp_security, smtp_verify_peer, smtp_verify_host, smtp_authentication;

	// 打印调试信息
	zabbix_log(LOG_LEVEL_DEBUG, "Enter %s()", __function_name);

	// 如果媒体类型数量为0，直接退出
	if (0 == mediatypeids_num)
		goto out;

	// 构造查询语句，从数据库中获取媒体类型信息
	zbx_strcpy_alloc(&sql, &sql_alloc, &sql_offset,
			"select mediatypeid,type,description,smtp_server,smtp_helo,smtp_email,exec_path,gsm_modem,"
				"username,passwd,smtp_port,smtp_security,smtp_verify_peer,smtp_verify_host,"
				"smtp_authentication,exec_params,maxsessions,maxattempts,attempt_interval"
			" from media_type"
			" where");

	// 添加查询条件，根据媒体类型ID进行筛选
	DBadd_condition_alloc(&sql, &sql_alloc, &sql_offset, "mediatypeid", mediatypeids, mediatypeids_num);

	// 执行查询语句
	result = DBselect_once("%s", sql);
	zbx_free(sql);

	// 如果查询失败或数据库连接异常，返回失败
	if (NULL == result || (DB_RESULT)ZBX_DB_DOWN == result)
	{
		ret = FAIL;
		goto out;
	}

	// 遍历查询结果，更新媒体类型信息
	while (NULL != (row = DBfetch(result)))
	{
		// 检查SMTP端口是否为有效值
		if (FAIL == is_ushort(row[10], &smtp_port))
		{
			THIS_SHOULD_NEVER_HAPPEN;
			continue;
		}

		// 解析媒体类型ID、类型、SMTP安全设置、SMTP验证等参数
		ZBX_STR2UINT64(mediatypeid, row[0]);
		type = atoi(row[1]);
		ZBX_STR2UCHAR(smtp_security, row[11]);
		ZBX_STR2UCHAR(smtp_verify_peer, row[12]);
		ZBX_STR2UCHAR(smtp_verify_host, row[13]);
		ZBX_STR2UCHAR(smtp_authentication, row[14]);
		maxsessions = atoi(row[16]);
		maxattempts = atoi(row[17]);

		// 检查并更新尝试间隔
		if (FAIL == is_time_suffix(row[18], &attempt_interval, ZBX_LENGTH_UNLIMITED))
		{
			const ZBX_TABLE *table;
			const ZBX_FIELD *field;

			zabbix_log(LOG_LEVEL_WARNING, "Invalid attempt interval for media type \"%s\": %s",
					row[2], row[18]);

			if (NULL == (table = DBget_table("media_type")) ||
					NULL == (field = DBget_field(table, "attempt_interval")))
			{
				THIS_SHOULD_NEVER_HAPPEN;
				exit(EXIT_FAILURE);
			}

			attempt_interval = atoi(field->default_value);
		}

		// 更新媒体类型信息
		am_update_mediatype(manager, mediatypeid, type, row[2], row[3], row[4], row[5], row[6], row[7], row[8],
				row[9], smtp_port, smtp_security, smtp_verify_peer, smtp_verify_host,
				smtp_authentication, row[15], maxsessions, maxattempts, attempt_interval);
	}
	// 释放查询结果
	DBfree_result(result);

out:
	// 打印调试信息
	zabbix_log(LOG_LEVEL_DEBUG, "End of %s() mediatypes:%d", __function_name, mediatypeids_num);

	// 返回更新结果
	return ret;
}


		if (FAIL == is_time_suffix(row[18], &attempt_interval, ZBX_LENGTH_UNLIMITED))
		{
			const ZBX_TABLE	*table;
			const ZBX_FIELD	*field;

			zabbix_log(LOG_LEVEL_WARNING, "Invalid attempt interval for media type \"%s\": %s",
					row[2], row[18]);

			if (NULL == (table = DBget_table("media_type")) ||
					NULL == (field = DBget_field(table, "attempt_interval")))
			{
				THIS_SHOULD_NEVER_HAPPEN;
				exit(EXIT_FAILURE);
			}

			attempt_interval = atoi(field->default_value);
		}

		am_update_mediatype(manager, mediatypeid, type, row[2], row[3], row[4], row[5], row[6], row[7], row[8],
				row[9], smtp_port, smtp_security, smtp_verify_peer, smtp_verify_host,
				smtp_authentication, row[15], maxsessions, maxattempts, attempt_interval);
	}
	DBfree_result(result);
out:
	zabbix_log(LOG_LEVEL_DEBUG, "End of %s() mediatypes:%d", __function_name, mediatypeids_num);

	return ret;
}

/******************************************************************************
 *                                                                            *
 * Function: am_db_queue_alerts                                               *
 *                                                                            *
 * Purpose: queues new alerts from database                                   *
 *                                                                            *
 * Parameters: manager - [IN] the alert manager                               *
 *             now     - [IN] the current timestamp                           *
 *                                                                            *
 * Return value: SUCCEED - alerts were queued successfully                    *
 *               FAIL    - database connection error                          *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *该代码块的主要目的是处理数据库中的警报数据，并将新的警报添加到相应的警报池中。具体来说，代码首先从数据库中获取警报数据，并将它们存储在一个向量中。然后，它更新与这些警报相关的媒体类型，并将它们添加到管理器中。最后，代码将警报添加到相应的警报池中，以便进一步处理。整个函数的执行过程会记录详细的日志，以便于调试和监控。
 ******************************************************************************/
// 定义一个静态函数，用于处理数据库中的警报数据
static int am_db_queue_alerts(zbx_am_t *manager, int now)
{
    // 定义一些变量，用于处理警报和媒体类型
    const char *__function_name = "am_db_queue_alerts";
    zbx_am_alert_t *alert;
    zbx_vector_ptr_t alerts;
    int i, ret;
    zbx_am_alertpool_t *alertpool;
    zbx_am_mediatype_t *mediatype;
    zbx_vector_uint64_t mediatypeids;
    zbx_hashset_iter_t iter;

    // 记录日志，表示函数开始执行
    zabbix_log(LOG_LEVEL_DEBUG, "In %s()", __function_name);

    // 创建一个 vector 用于存储警报
    zbx_vector_ptr_create(&alerts);

    // 从数据库中获取警报数据，并将结果存储在 alerts 向量中
    if (FAIL == (ret = am_db_get_alerts(manager, &alerts, now)))
        goto out;

    // 更新媒体类型，以便处理新的警报

    // 创建一个 vector 用于存储媒体类型 ID
    zbx_vector_uint64_create(&mediatypeids);

    // 遍历 alerts 向量中的每个警报，并将媒体类型 ID 添加到 mediatypeids 向量中
    for (i = 0; i < alerts.values_num; i++)
    {
        alert = (zbx_am_alert_t *)alerts.values[i];
        zbx_vector_uint64_append(&mediatypeids, alert->mediatypeid);
    }

    // 遍历 manager 中的所有媒体类型，并将未在 alerts 中的媒体类型 ID 添加到 mediatypeids 向量中
    zbx_hashset_iter_reset(&manager->mediatypes, &iter);
    while (NULL != (mediatype = (zbx_am_mediatype_t *)zbx_hashset_iter_next(&iter)))
        zbx_vector_uint64_append(&mediatypeids, mediatype->mediatypeid);

    // 如果 mediatypeids 向量不为空，则对媒体类型进行更新操作
    if (0 != mediatypeids.values_num)
    {
        zbx_vector_uint64_sort(&mediatypeids, ZBX_DEFAULT_UINT64_COMPARE_FUNC);
        zbx_vector_uint64_uniq(&mediatypeids, ZBX_DEFAULT_UINT64_COMPARE_FUNC);

        // 更新媒体类型到数据库
        ret = am_db_update_mediatypes(manager, mediatypeids.values, mediatypeids.values_num);
    }

    // 销毁 mediatypeids 向量
    zbx_vector_uint64_destroy(&mediatypeids);

    // 如果更新媒体类型操作失败，跳出函数
    if (FAIL == ret)
        goto out;

    // 处理新的警报

    // 遍历 alerts 向量中的每个警报
    for (i = 0; i < alerts.values_num; i++)
    {
        alert = (zbx_am_alert_t *)alerts.values[i];

        // 获取对应的媒体类型
        if (NULL == (mediatype = am_get_mediatype(manager, alert->mediatypeid)))
        {
            // 释放警报内存
            am_alert_free(alert);
            continue;
        }

        // 获取对应的警报池
        alertpool = am_get_alertpool(manager, alert->mediatypeid, alert->alertpoolid);

        // 增加警报池引用计数
        alertpool->refcount++;
        mediatype->refcount++;

        // 将警报添加到警报池
        am_push_alert(alertpool, alert);

        // 将警报池添加到媒体类型
/******************************************************************************
 * 以下是对代码块的逐行注释：
 *
 *
 *
 *整个代码块的主要目的是执行以下操作：
 *
 *1. 检查管理器中的更新数据是否为空，如果为空，则直接返回成功。
 *2. 创建一个zbx_vector结构体，用于存储从管理器中获取的更新数据。
 *3. 迭代管理器中的警报更新数据，并将迭代到的更新数据添加到zbx_vector中。
 *4. 对zb_vector中的更新数据进行排序。
 *5. 尝试连接数据库，如果连接失败，则跳转到清理标签cleanup。
 *6. 分批处理更新数据，每次处理一定数量的更新数据。
 *7. 拼接SQL更新语句，并将更新数据的状态、重试次数和错误字符串更新到数据库中。
 *8. 执行SQL更新语句，如果执行失败，则跳转到清理标签cleanup。
 *9. 提交数据库操作，如果提交失败，则跳转到清理标签cleanup。
 *10. 释放不再需要的内存，包括SQL语句、更新数据和zbx_vector。
 *11. 打印调试日志，表示函数执行结束。
 *12. 返回函数执行结果。
 ******************************************************************************/
static int	am_db_flush_alert_updates(zbx_am_t *manager)
{
	const char		*__function_name = "am_db_flush_alert_updates"; // 定义一个常量字符串，表示函数名

	zbx_vector_ptr_t	updates; // 创建一个指向zbx_vector的结构体的指针变量updates，用于存储更新数据
	zbx_hashset_iter_t	iter; // 创建一个zbx_hashset_iter结构体的指针变量iter，用于迭代管理器中的警报更新数据
	zbx_am_alertstatus_t	*update; // 定义一个指向zbx_am_alertstatus结构体的指针变量update
	char			*sql = NULL, *error_esc; // 定义两个字符指针变量sql和error_esc，用于存储SQL语句和错误转义字符串
	size_t			sql_alloc = 0, sql_offset = 0; // 定义两个size_t类型的变量sql_alloc和sql_offset，用于存储SQL语句的分配大小和偏移量
	int			i, j, ret = FAIL, limit; // 定义一些整型变量i、j、ret、limit，用于循环和判断函数返回值

	zabbix_log(LOG_LEVEL_DEBUG, "In %s() updates:%d", __function_name, manager->alertupdates.num_data); // 打印调试日志，表示函数开始执行，传入参数和更新数据数量

	if (0 == manager->alertupdates.num_data) // 如果管理器中的更新数据为0
	{
		ret = SUCCEED; // 函数执行成功
		goto out; // 跳转到函数结束标签out
	}

	zbx_vector_ptr_create(&updates); // 创建一个zbx_vector结构体，用于存储从管理器中获取的更新数据

	zbx_hashset_iter_reset(&manager->alertupdates, &iter); // 重置iter变量，用于迭代管理器中的警报更新数据
	while (NULL != (update = (zbx_am_alertstatus_t *)zbx_hashset_iter_next(&iter))) // 遍历迭代更新数据
		zbx_vector_ptr_append(&updates, update); // 将迭代到的更新数据添加到zbx_vector中

	zbx_vector_ptr_sort(&updates, ZBX_DEFAULT_UINT64_PTR_COMPARE_FUNC); // 对zb_vector中的更新数据进行排序

	if (ZBX_DB_DOWN == zbx_db_begin()) // 如果数据库连接失败
		goto cleanup; // 跳转到清理标签cleanup

#if defined(HAVE_ORACLE) && 0 == ZBX_MAX_OVERFLOW_SQL_SIZE
#	define ZBX_SQL_UPDATE_BATCH_SIZE	1
#	define ZBX_SQL_DELIMITER
#else
#	define ZBX_SQL_UPDATE_BATCH_SIZE	100
#	define ZBX_SQL_DELIMITER		";\
"
#endif

	for (i = 0; i < updates.values_num; i += ZBX_SQL_UPDATE_BATCH_SIZE) // 分批处理更新数据
	{
		sql_offset = 0; // 初始化sql_offset为0

		limit = MIN(i + ZBX_SQL_UPDATE_BATCH_SIZE, updates.values_num); // 计算每次处理的更新数据数量上限

#if !defined(HAVE_ORACLE) || 0 != ZBX_MAX_OVERFLOW_SQL_SIZE
		DBbegin_multiple_update(&sql, &sql_alloc, &sql_offset); // 开始执行多条SQL更新语句
#endif

		for (j = i; j < limit; j++) // 遍历每次处理的更新数据
		{
			update = (zbx_am_alertstatus_t *)updates.values[j]; // 获取当前处理的更新数据

			error_esc = DBdyn_escape_string_len(update->error, ALERT_ERROR_LEN); // 动态转义更新数据的错误字符串

			zbx_snprintf_alloc(&sql, &sql_alloc, &sql_offset, // 拼接SQL更新语句
					"update alerts"
					" set status=%d,"
						"retries=%d,"
						"error='%s'"
					" where alertid=" ZBX_FS_UI64 ZBX_SQL_DELIMITER,
					update->status, update->retries, error_esc, update->alertid);

			zbx_free(error_esc); // 释放错误转义字符串内存
		}

#if !defined(HAVE_ORACLE) || 0 != ZBX_MAX_OVERFLOW_SQL_SIZE
		DBend_multiple_update(&sql, &sql_alloc, &sql_offset); // 结束执行多条SQL更新语句
#endif

		if (16 < sql_offset && ZBX_DB_DOWN == DBexecute_once("%s", sql)) // 如果SQL语句执行失败
			goto cleanup; // 跳转到清理标签cleanup
	}

	if (ZBX_DB_DOWN == zbx_db_commit()) // 如果数据库提交失败
		goto cleanup; // 跳转到清理标签cleanup

	zbx_hashset_iter_reset(&manager->alertupdates, &iter); // 重置iter变量，用于迭代管理器中的警报更新数据
	while (NULL != (update = (zbx_am_alertstatus_t *)zbx_hashset_iter_next(&iter))) // 遍历迭代更新数据
		zbx_free(update->error); // 释放更新数据的错误字符串内存

	zbx_hashset_clear(&manager->alertupdates); // 清空管理器中的更新数据

	ret = SUCCEED; // 函数执行成功
cleanup:
	zbx_free(sql); // 释放SQL语句内存
	zbx_vector_ptr_destroy(&updates); // 释放zbx_vector内存
out:
	zabbix_log(LOG_LEVEL_DEBUG, "End of %s():%s", __function_name, zbx_result_string(ret)); // 打印调试日志，表示函数执行结束

	return ret;
}


			zbx_free(error_esc);
		}

#if !defined(HAVE_ORACLE) || 0 != ZBX_MAX_OVERFLOW_SQL_SIZE
		DBend_multiple_update(&sql, &sql_alloc, &sql_offset);
#endif

		if (16 < sql_offset && ZBX_DB_DOWN == DBexecute_once("%s", sql))
			goto cleanup;
	}

	if (ZBX_DB_DOWN == zbx_db_commit())
		goto cleanup;
/******************************************************************************
 * *
 *这个C代码块的主要目的是对zbx_am_t结构体的manager成员进行数据库同步操作，包括查询活跃状态的媒体信息、更新媒体类型缓存、增加媒体类型引用计数、删除不再使用的媒体以及检查数据库同步状态等。在整个过程中，会对媒体ID、媒体类型ID、发送地址等数据进行处理和更新。
 ******************************************************************************/
// 定义一个静态整型变量，表示之前的数据库同步状态
static int old_count = -1;

// 定义一个C函数，用于数据库同步监控
static int am_db_sync_watchdog(zbx_am_t *manager)
{
    // 定义一些变量，用于后续操作
    const char *__function_name = "am_db_sync_watchdog";
    DB_RESULT result;
    DB_ROW row;
    int i, ret = SUCCEED;
    zbx_hashset_t mediaids;
    zbx_uint64_t mediaid;
    zbx_am_media_t *media, media_local;
    zbx_hashset_iter_t iter;
    zbx_vector_uint64_t mediatypeids;
    zbx_vector_ptr_t media_new;
    zbx_am_mediatype_t *mediatype;

    // 打印日志，表示函数开始执行
    zabbix_log(LOG_LEVEL_DEBUG, "In %s()", __function_name);

    // 从数据库中查询活跃状态的媒体信息
    result = DBselect_once(
            "select m.mediaid,m.mediatypeid,m.sendto"
            " from media m,users_groups u,config c,media_type mt"
            " where m.userid=u.userid"
            " and u.usrgrpid=c.alert_usrgrpid"
            " and m.mediatypeid=mt.mediatypeid"
            " and m.active=%d"
            " and mt.status=%d",
            MEDIA_STATUS_ACTIVE,
            MEDIA_TYPE_STATUS_ACTIVE);

    // 判断查询结果是否有效，如果无效，返回失败
    if (NULL == result || (DB_RESULT)ZBX_DB_DOWN == result)
    {
        ret = FAIL;
        goto out;
    }

    // 创建一些数据结构，用于后续操作
    zbx_hashset_create(&mediaids, 100, ZBX_DEFAULT_UINT64_HASH_FUNC, ZBX_DEFAULT_UINT64_COMPARE_FUNC);
    zbx_vector_uint64_create(&mediatypeids);
    zbx_vector_ptr_create(&media_new);

    /* read watchdog alert recipients */
    // 遍历查询结果，处理每个媒体信息
    while (NULL != (row = DBfetch(result)))
    {
        // 将媒体ID转换为zbx_uint64类型
        ZBX_STR2UINT64(mediaid, row[0]);

        // 判断媒体是否已经存在于监控列表中，如果不存在，则新添加
        if (NULL == (media = (zbx_am_media_t *)zbx_hashset_search(&manager->watchdog, &mediaid)))
        {
            media_local.mediaid = mediaid;
            media = (zbx_am_media_t *)zbx_hashset_insert(&manager->watchdog, &media_local, sizeof(media_local));
            media->sendto = NULL;

            // 添加媒体到新的列表中
            zbx_vector_ptr_append(&media_new, media);
        }

        // 转换媒体类型ID
        ZBX_STR2UINT64(media->mediatypeid, row[1]);
        // 更新发送地址
        ZBX_UPDATE_STR(media->sendto, row[2]);

        // 将媒体ID添加到hashset中，便于后续处理
        zbx_hashset_insert(&mediaids, &mediaid, sizeof(mediaid));

        // 记录媒体类型ID
        zbx_vector_uint64_append(&mediatypeids, media->mediatypeid);
    }
    DBfree_result(result);

    /* update media types used for watchdog alerts */
    // 对媒体类型ID进行排序和去重
    zbx_vector_uint64_sort(&mediatypeids, ZBX_DEFAULT_UINT64_COMPARE_FUNC);
    zbx_vector_uint64_uniq(&mediatypeids, ZBX_DEFAULT_UINT64_COMPARE_FUNC);

    // 更新媒体类型缓存
    ret = am_db_update_mediatypes(manager, mediatypeids.values, mediatypeids.values_num);

    /* increase media type reference count for the new watchdog alerts */
    // 遍历新的媒体列表，增加媒体类型引用计数
    for (i = 0; i < media_new.values_num; i++)
    {
        media = (zbx_am_media_t *)media_new.values[i];

        // 如果存在该媒体类型，则增加引用计数
        if (NULL != (mediatype = am_get_mediatype(manager, media->mediatypeid)))
            mediatype->refcount++;
    }

    /* drop removed watchdog alert recipients from cache */
    // 遍历监控列表，删除不再使用的媒体
    zbx_hashset_iter_reset(&manager->watchdog, &iter);
    while (NULL != (media = (zbx_am_media_t *)zbx_hashset_iter_next(&iter)))
    {
        // 如果媒体ID存在于之前记录的列表中，则继续处理
        if (NULL != zbx_hashset_search(&mediaids, &media->mediaid))
            continue;

        // 如果存在媒体类型，则释放资源
        if (NULL != (mediatype = am_get_mediatype(manager, media->mediatypeid)))
            am_release_mediatype(manager, mediatype);

        // 释放发送地址内存
        zbx_free(media->sendto);
        // 移除媒体记录
        zbx_hashset_iter_remove(&iter);
    }

    // 释放新添加的媒体列表
    zbx_vector_ptr_destroy(&media_new);
    // 释放媒体类型ID列表
    zbx_vector_uint64_destroy(&mediatypeids);
    // 释放媒体ID列表
    zbx_hashset_destroy(&mediaids);

    // 检查数据库同步状态
    if (0 < old_count && 0 == manager->watchdog.num_data)
    {
        // 如果之前存在监控数据，但当前为空，则打印警告信息
        zabbix_log(LOG_LEVEL_WARNING, "watchdog: no recipients found for database down messages");
    }
    else if (0 == old_count && 0 < manager->watchdog.num_data)
    {
        // 如果之前没有监控数据，但当前存在，则打印警告信息
        zabbix_log(LOG_LEVEL_WARNING, "watchdog: %d recipient(s) found for database down messages",
                  manager->watchdog.num_data);
    }

    // 更新监控数据数量
    old_count = manager->watchdog.num_data;

out:
    // 打印日志，表示函数执行结束
    zabbix_log(LOG_LEVEL_DEBUG, "End of %s():%s recipients:%d", __function_name,
              zbx_result_string(ret), manager->watchdog.num_data);

    // 返回操作结果
    return ret;
}

			continue;

		if (NULL != (mediatype = am_get_mediatype(manager, media->mediatypeid)))
			am_release_mediatype(manager, mediatype);

		zbx_free(media->sendto);
		zbx_hashset_iter_remove(&iter);
	}

	zbx_vector_ptr_destroy(&media_new);
	zbx_vector_uint64_destroy(&mediatypeids);
	zbx_hashset_destroy(&mediaids);

	if (0 < old_count && 0 == manager->watchdog.num_data)
	{
		zabbix_log(LOG_LEVEL_WARNING, "watchdog: no recipients found for database down messages");
	}
	else if (0 == old_count && 0 < manager->watchdog.num_data)
	{
		zabbix_log(LOG_LEVEL_WARNING, "watchdog: %d recipient(s) found for database down messages",
				manager->watchdog.num_data);
	}

	old_count = manager->watchdog.num_data;
out:
	zabbix_log(LOG_LEVEL_DEBUG, "End of %s():%s recipients:%d", __function_name, zbx_result_string(ret),
			manager->watchdog.num_data);

	return ret;
}

/******************************************************************************
 *                                                                            *
 * Function: am_prepare_mediatype_exec_command                                *
 *                                                                            *
 * Purpose: gets script media type parameters with expanded macros            *
 *                                                                            *
 * Parameters: mediatype - [IN] the media type                                *
 *             alert     - [IN] the alert                                     *
 *             cmd       - [OUT] the command to execute                       *
 *             error     - [OUT] the error message                            *
 *                                                                            *
 * Return value: SUCCEED - the command was prepared successfully              *
 *               FAIL    - otherwise                                          *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *整个代码块的主要目的是准备媒体类型执行命令。该函数接收四个参数：一个媒体类型结构体、一个警报结构体、一个命令指针和一个错误指针。函数首先检查命令文件是否具有执行权限，然后遍历媒体类型执行参数，并替换简单宏。最后，将生成的命令字符串和错误信息返回给调用者。
 ******************************************************************************/
// 定义一个静态函数，用于准备媒体类型执行命令
static int	am_prepare_mediatype_exec_command(zbx_am_mediatype_t *mediatype, zbx_am_alert_t *alert, char **cmd,
                                            char **error)
{
    // 定义一个DB_ALERT结构体，用于存储警报信息
    DB_ALERT	db_alert;
    // 分配命令空间，初始值为1KB
    size_t		cmd_alloc = ZBX_KIBIBYTE, cmd_offset = 0;
    // 初始化返回值
    int		ret = FAIL;

    // 为命令分配内存空间
    *cmd = (char *)zbx_malloc(NULL, cmd_alloc);

    // 拼接命令字符串，格式为：配置警报脚本路径/媒体类型执行路径
    zbx_snprintf_alloc(cmd, &cmd_alloc, &cmd_offset, "%s/%s", CONFIG_ALERT_SCRIPTS_PATH, mediatype->exec_path);

    // 检查命令文件是否具有执行权限
    if (0 == access(*cmd, X_OK))
    {
        // 提取警报信息的发送人、主题和消息
        db_alert.sendto = alert->sendto;
        db_alert.subject = alert->subject;
        db_alert.message = alert->message;

        // 遍历媒体类型执行参数
        for (pstart = mediatype->exec_params; NULL != (pend = strchr(pstart, '\
')); pstart = pend + 1)
        {
            // 分配参数空间
            char	*param_alloc = 0;
            char	*param = NULL;
            size_t	param_offset = 0;

            zbx_strncpy_alloc(&param, &param_alloc, &param_offset, pstart, pend - pstart);

            // 替换简单宏
            substitute_simple_macros(NULL, NULL, NULL, NULL, NULL, NULL, NULL, &db_alert, NULL, &param,
                                    MACRO_TYPE_ALERT, NULL, 0);

            // 对参数进行转义
            param_esc = zbx_dyn_escape_shell_single_quote(param);
            // 拼接命令字符串
            zbx_snprintf_alloc(cmd, &cmd_alloc, &cmd_offset, " '%s'", param_esc);

            // 释放内存
            zbx_free(param_esc);
            zbx_free(param);
        }

        // 设置返回值为成功
        ret = SUCCEED;
    }
    else
    {
        // 失败时，记录错误信息
        *error = zbx_dsprintf(*error, "Cannot exectue command \"%s\": %s", *cmd, zbx_strerror(errno));
        // 释放命令内存
        zbx_free(*cmd);
    }

    // 返回处理结果
    return ret;
}


/******************************************************************************
 *                                                                            *
 * Function: am_process_alert                                                 *
 *                                                                            *
 * Purpose: sends alert to the alerter                                        *
 *                                                                            *
 * Parameters: manager - [IN] the alert manager                               *
 *             alerter - [IN] the target alerter                              *
 *             alert   - [IN] the alert to send                               *
 *                                                                            *
 * Return value: SUCCEED - the alert was successfully sent to alerter         *
 *               FAIL    - otherwise                                          *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *这个代码块的主要目的是处理传入的警报信息，根据警报的媒介类型进行相应的处理，并将处理结果发送给对应的警报处理客户端。具体来说，代码完成了以下功能：
 *
 *1. 接收传入的警报信息，包括警报ID、媒介类型ID、警报池ID等。
 *2. 获取媒介类型。
 *3. 根据媒介类型，对警报信息进行序列化处理，生成数据。
 *4. 将数据发送给对应的警报处理客户端。
 *5. 释放内存，返回处理结果。
 ******************************************************************************/
// 定义一个静态函数，用于处理警报
static int am_process_alert(zbx_am_t *manager, zbx_am_alerter_t *alerter, zbx_am_alert_t *alert)
{
	// 定义一些变量，用于存储媒介类型、数据等信息
	zbx_am_mediatype_t *mediatype;
	unsigned char *data = NULL;
	size_t data_len;
	zbx_uint64_t command;
	char *cmd = NULL, *error = NULL;
	int ret = FAIL;

	// 打印日志，记录警报信息
	zabbix_log(LOG_LEVEL_DEBUG, "%s() alertid:%llu mediatypeid:%llu alertpoolid:%llu", __function_name, alert->alertid, alert->mediatypeid, alert->alertpoolid);

	// 获取媒介类型
	if (NULL == (mediatype = am_get_mediatype(manager, alert->mediatypeid)))
	{
		am_alert_free(alert);
		goto out;
	}

	// 根据媒介类型进行切换处理
	switch (mediatype->type)
	{
		case MEDIA_TYPE_EMAIL:
			command = ZBX_IPC_ALERTER_EMAIL;
			data_len = zbx_alerter_serialize_email(&data, alert->alertid, alert->sendto, alert->subject,
					alert->message, mediatype->smtp_server, mediatype->smtp_port,
					mediatype->smtp_helo, mediatype->smtp_email, mediatype->smtp_security,
					mediatype->smtp_verify_peer, mediatype->smtp_verify_host,
					mediatype->smtp_authentication, mediatype->username, mediatype->passwd);
			break;
		case MEDIA_TYPE_JABBER:
			command = ZBX_IPC_ALERTER_JABBER;
			data_len = zbx_alerter_serialize_jabber(&data, alert->alertid, alert->sendto, alert->subject,
					alert->message, mediatype->username, mediatype->passwd);
			break;
		case MEDIA_TYPE_SMS:
			command = ZBX_IPC_ALERTER_SMS;
			data_len = zbx_alerter_serialize_sms(&data, alert->alertid, alert->sendto, alert->message,
					mediatype->gsm_modem);
			break;
		case MEDIA_TYPE_EZ_TEXTING:
			command = ZBX_IPC_ALERTER_EZTEXTING;
			data_len = zbx_alerter_serialize_eztexting(&data, alert->alertid, alert->sendto, alert->message,
					mediatype->username, mediatype->passwd, mediatype->exec_path);
			break;
		case MEDIA_TYPE_EXEC:
			command = ZBX_IPC_ALERTER_EXEC;
			if (FAIL == am_prepare_mediatype_exec_command(mediatype, alert, &cmd, &error))
			{
				am_db_update_alert(manager, alert->alertid, ALERT_STATUS_FAILED, 0, error);
				am_remove_alert(manager, alert);
				zbx_free(error);
				goto out;
			}
			data_len = zbx_alerter_serialize_exec(&data, alert->alertid, cmd);
			zbx_free(cmd);
			break;
		default:
			am_db_update_alert(manager, alert->alertid, ALERT_STATUS_FAILED, 0, (char *)"unsupported media type");
			zabbix_log(LOG_LEVEL_ERR, "cannot process alertid:%llu: unsupported media type:%d",
					alert->alertid, mediatype->type);
			am_remove_alert(manager, alert);
			goto out;
	}

	// 将数据发送给警报处理客户端
	alerter->alert = alert;
	zbx_ipc_client_send(alerter->client, command, data, data_len);
	// 释放数据内存
	zbx_free(data);

	// 设置返回值
	ret = SUCCEED;
out:
	// 打印日志，记录结束信息
	zabbix_log(LOG_LEVEL_DEBUG, "End of %s()", __function_name);

	// 返回处理结果
	return ret;
}


/******************************************************************************
 *                                                                            *
 * Function: am_process_result                                                *
 *                                                                            *
 * Purpose: process alerter result                                            *
 *                                                                            *
 * Parameters: manager - [IN] the manager                                     *
 *             client  - [IN] the connected alerter                           *
 *             message - [IN] the received message                            *
 *                                                                            *
 * Return value: SUCCEED - the alert was sent successfully                    *
 *               FAIL - otherwise                                             *
 *                                                                            *
 ******************************************************************************/
/******************************************************************************
 * *
 *整个代码块的主要目的是处理接收到的alerter结果，根据结果更新数据库中的alert信息，并删除已处理的alerter。在这个过程中，还对alerter进行了重试操作。最后，将处理过的alerter放入自由列表，以便后续继续使用。
 ******************************************************************************/
static int am_process_result(zbx_am_t *manager, zbx_ipc_client_t *client, zbx_ipc_message_t *message)
{
	const char *__function_name = "am_process_result"; // 定义一个常量字符串，表示函数名

	int ret = FAIL, errcode, status; // 声明变量，用于存储函数返回值、错误码和状态
	char *errmsg; // 声明一个字符串指针，用于存储错误信息
	zbx_am_alerter_t *alerter; // 声明一个alerter结构体指针，用于存储alerter信息

	zabbix_log(LOG_LEVEL_DEBUG, "In %s()", __function_name); // 记录日志，表示函数开始执行

	if (NULL == (alerter = am_get_alerter_by_client(manager, client)))
	{
		THIS_SHOULD_NEVER_HAPPEN; // 表示这种情况不应该发生
		goto out; // 跳转到out标签处
	}

	if (NULL == alerter->alert)
	{
		THIS_SHOULD_NEVER_HAPPEN; // 表示这种情况不应该发生
		goto out; // 跳转到out标签处
	}

	zabbix_log(LOG_LEVEL_DEBUG, "%s() alertid:" ZBX_FS_UI64 " mediatypeid:" ZBX_FS_UI64 " alertpoolid:"
			ZBX_FS_UI64, __function_name, alerter->alert->alertid, alerter->alert->mediatypeid,
			alerter->alert->alertpoolid); // 记录日志，表示处理的alerter信息

	zbx_alerter_deserialize_result(message->data, &errcode, &errmsg); // 反序列化alerter结果

	if (SUCCEED == errcode) // 如果反序列化成功
	{
		errmsg = zbx_strdup(errmsg, ""); // 复制错误信息为空字符串
		status = ALERT_STATUS_SENT; // 设置状态为已发送
		ret = SUCCEED; // 设置返回值为成功
	}
	else
	{
		if (SUCCEED == am_retry_alert(manager, alerter->alert)) // 如果重试alert成功
			status = ALERT_STATUS_NOT_SENT; // 设置状态为未发送
		else
			status = ALERT_STATUS_FAILED; // 设置状态为发送失败
	}

	am_db_update_alert(manager, alerter->alert->alertid, status, alerter->alert->retries, errmsg); // 更新数据库中的alert信息

	if (ALERT_STATUS_NOT_SENT != status) // 如果状态不是未发送
		am_remove_alert(manager, alerter->alert); // 删除已处理的alerter

	alerter->alert = NULL; // 清除alerter指针
	zbx_free(errmsg); // 释放错误信息内存

	zbx_queue_ptr_push(&manager->free_alerters, alerter); // 将alerter放入自由列表
out:
	zabbix_log(LOG_LEVEL_DEBUG, "End of %s()", __function_name); // 记录日志，表示函数执行结束

	return ret; // 返回函数执行结果
/******************************************************************************
 * *
 *这个代码块的主要目的是实现一个C语言程序，该程序作为一个警报管理线程运行。其主要功能包括：
 *
 *1. 初始化警报管理服务、警报管理器、数据库连接等；
 *2. 循环接收客户端发送的警报消息，并处理这些消息；
 *3. 定期检查数据库连接状态，如果断开则重新连接；
 *4. 发送警报器队列中的警报；
 *5. 处理客户端注册和结果消息；
 *6. 在程序运行期间持续监控状态，直到程序终止。
 *
 *整个代码块以注释的形式详细说明了每个步骤的目的和实现方法，对于初学者来说，非常适合用来学习C语言编程以及线程、IPC、数据库等概念的应用。
 ******************************************************************************/
ZBX_THREAD_ENTRY(alert_manager_thread, args)
{
    // 定义STAT_INTERVAL为5，表示如果进程忙碌且不睡眠，则更新状态不超过STAT_INTERVAL秒

    zbx_ipc_service_t alerter_service;
    zbx_am_t manager;
    char *error = NULL;
    zbx_ipc_client_t *client;
    zbx_ipc_message_t *message;
    zbx_am_alerter_t *alerter;
    int ret, sent_num = 0, failed_num = 0, now, time_db = 0, time_watchdog = 0, freq_watchdog;
    int time_connect;
    double time_stat, time_idle = 0, time_now, sec;

    // 获取进程类型、服务器编号和进程编号
    process_type = ((zbx_thread_args_t *)args)->process_type;
    server_num = ((zbx_thread_args_t *)args)->server_num;
    process_num = ((zbx_thread_args_t *)args)->process_num;

    // 设置进程标题
    zbx_setproctitle("%s #%d starting", get_process_type_string(process_type), process_num);

    // 初始化日志记录器
    zabbix_log(LOG_LEVEL_INFORMATION, "%s #%d started [%s #%d]", get_program_type_string(program_type),
                server_num, get_process_type_string(process_type), process_num);

    // 更新自我监控计数器
    update_selfmon_counter(ZBX_PROCESS_STATE_BUSY);

    // 启动警报管理服务
    if (FAIL == zbx_ipc_service_start(&alerter_service, ZBX_IPC_SERVICE_ALERTER, &error))
    {
        // 如果无法启动警报管理服务，输出错误日志并释放错误字符串，然后退出程序
        zabbix_log(LOG_LEVEL_CRIT, "cannot start alert manager service: %s", error);
        zbx_free(error);
        exit(EXIT_FAILURE);
    }

    // 初始化警报管理器
    am_init(&manager);

    // 连接数据库
    manager.dbstatus = DBconnect(ZBX_DB_CONNECT_NORMAL);

    // 初始化统计数据
    time_stat = zbx_time();
    time_connect = time_stat;

    // 设置警报器注册频率
    if (ZBX_WATCHDOG_ALERT_FREQUENCY < (freq_watchdog = CONFIG_CONFSYNCER_FREQUENCY))
        freq_watchdog = ZBX_WATCHDOG_ALERT_FREQUENCY;

    // 设置进程标题
    zbx_setproctitle("%s #%d started", get_process_type_string(process_type), process_num);

    // 进入循环，直到程序正在运行
    while (ZBX_IS_RUNNING())
    {
        // 获取当前时间
        time_now = zbx_time();
        now = time_now;

        // 如果数据库连接失败且时间连接加上ZBX_DB_WAIT_DOWN仍然小于现在，则重新连接数据库
        if (ZBX_DB_DOWN == manager.dbstatus && time_connect + ZBX_DB_WAIT_DOWN <= now)
        {
            // 如果重新连接数据库成功，则发送警报器队列中的警报
            if (ZBX_DB_DOWN == (manager.dbstatus = DBconnect(ZBX_DB_CONNECT_ONCE)))
            {
                am_queue_watchdog_alerts(&manager);

                // 记录日志并输出警报重新连接信息
                zabbix_log(LOG_LEVEL_ERR, "database is down: reconnecting in %d seconds",
                           ZBX_DB_WAIT_DOWN);
            }
            else if (0 != zbx_db_txn_level() && ZBX_DB_OK > zbx_db_rollback())
            {
                // 如果数据库连接失败，关闭数据库并退出程序
                manager.dbstatus = ZBX_DB_DOWN;
                DBclose();
            }

            // 如果数据库连接成功，记录日志
            if (ZBX_DB_OK == manager.dbstatus)
                zabbix_log(LOG_LEVEL_ERR, "database connection re-established");

            // 更新连接时间
            time_connect = now;
        }

        // 如果有新的警报，处理警报
        while (SUCCEED == am_check_queue(&manager, now))
        {
            // 获取一个可用的警报器
            if (NULL == (alerter = (zbx_am_alerter_t *)zbx_queue_ptr_pop(&manager.free_alerters)))
                break;

            // 处理警报并发送给客户端
            if (FAIL == am_process_alert(&manager, alerter, am_pop_alert(&manager)))
            {
                // 发送失败，将警报器放回队列
                zbx_queue_ptr_push(&manager.free_alerters, alerter);
            }
        }

        // 更新自我监控计数器
        update_selfmon_counter(ZBX_PROCESS_STATE_IDLE);

        // 接收客户端发送的警报消息
        ret = zbx_ipc_service_recv(&alerter_service, 1, &client, &message);

        // 更新自我监控计数器
        update_selfmon_counter(ZBX_PROCESS_STATE_BUSY);

        // 处理接收到的消息
        sec = zbx_time();
        zbx_update_env(sec);

        // 如果接收到的消息不是立即处理，则累计处理时间
        if (ZBX_IPC_RECV_IMMEDIATE != ret)
            time_idle += sec - time_now;

        // 处理完消息后释放客户端和消息
        if (NULL != message)
        {
            switch (message->code)
            {
                case ZBX_IPC_ALERTER_REGISTER:
                    // 处理注册消息
                    am_register_alerter(&manager, client, message);
                    break;
                case ZBX_IPC_ALERTER_RESULT:
                    // 处理结果消息
                    if (SUCCEED == am_process_result(&manager, client, message))
                        sent_num++;
                    else
                        failed_num++;
                    break;
            }

            // 释放消息
            zbx_ipc_message_free(message);
        }

        if (NULL != client)
            zbx_ipc_client_release(client);
    }

    // 输出结束信息
    zbx_setproctitle("%s #%d [terminated]", get_process_type_string(process_type), process_num);

    // 进入死循环，等待1分钟后再退出程序
    while (1)
        zbx_sleep(SEC_PER_MIN);

    // 关闭警报管理服务
    zbx_ipc_service_close(&alerter_service);
    // 销毁警报管理器
    am_destroy(&manager);

    // 关闭数据库
    DBclose();
}

			time_db = now;
		}

		if (ZBX_DB_OK == manager.dbstatus && now - time_watchdog >= freq_watchdog)
		{
			if (FAIL == am_db_sync_watchdog(&manager))
			{
				manager.dbstatus = ZBX_DB_DOWN;
				DBclose();
			}

			time_watchdog = now;
		}

		now = time(NULL);

		while (SUCCEED == am_check_queue(&manager, now))
		{
			if (NULL == (alerter = (zbx_am_alerter_t *)zbx_queue_ptr_pop(&manager.free_alerters)))
				break;

			if (FAIL == am_process_alert(&manager, alerter, am_pop_alert(&manager)))
				zbx_queue_ptr_push(&manager.free_alerters, alerter);
		}

		update_selfmon_counter(ZBX_PROCESS_STATE_IDLE);
		ret = zbx_ipc_service_recv(&alerter_service, 1, &client, &message);
		update_selfmon_counter(ZBX_PROCESS_STATE_BUSY);

		sec = zbx_time();
		zbx_update_env(sec);

		if (ZBX_IPC_RECV_IMMEDIATE != ret)
			time_idle += sec - time_now;

		if (NULL != message)
		{
			switch (message->code)
			{
				case ZBX_IPC_ALERTER_REGISTER:
					am_register_alerter(&manager, client, message);
					break;
				case ZBX_IPC_ALERTER_RESULT:
					if (SUCCEED == am_process_result(&manager, client, message))
						sent_num++;
					else
						failed_num++;
					break;
			}

			zbx_ipc_message_free(message);
		}

		if (NULL != client)
			zbx_ipc_client_release(client);
	}

	zbx_setproctitle("%s #%d [terminated]", get_process_type_string(process_type), process_num);

	while (1)
		zbx_sleep(SEC_PER_MIN);

	zbx_ipc_service_close(&alerter_service);
	am_destroy(&manager);

	DBclose();
}
